# 디자인패턴 실전

말로만 봐도 잘 와닿지는 않을것이기 때문에 유명하고도 간단한 패턴 두가지에 대해서 더욱 자세히 알아보자.
<br>

## 팩토리 패턴

새로운 객체가 필요할 때, 특정 타입의 객체를 생산하는 역할만을 하는 클래스를 작성한다.

이후에 새로운 객체가 필요해진다면, 직접 만들지 않고 팩토리 클래스에게 해당 작업을 맡긴다.

<br>

### 동기
<br>
포션을 만들기로 정했다고 가정해 보자.

포션은 아이템이라는 부모 클래스를 가진다.

또한 포션은 여러가지 종류를 가지고있다.
하위 포션들은 포션을 부모로 가진다.

그럴 때, 여러가지 포션을 만든다고 하면 당장은 문제가 없겠지만, 후에 여러가지 문제가 발생한다.

만일 상속을 이용해서 여러 종류의 포션을 표현한다면 자잘한 하위 클래스가 너무 많아질 것이다.

그렇다고 다형성을 이용하여 만든다면, 서로 다른 포션을 만들 때, 각자의 속성들을 계속해서 바꿔주거나 해야하는데 이 과정에서 에러가 발생할 수 있다.

이와같이 초기값 등이 변하지 않고, 상속으로 구현할 정도의 클래스 구성이 아닐 경우에는 생성 에러를 피하기 위해 팩토리 패턴을 구성할 수 있다.

<br>

### 코드 예시
<br>
```cs
class Factory{
    public static Item MakeItem(type _type){
        
        Item ret;    

        switch(_type){

            case 포션:
                ret = new Potion();
                ret.name = "포션";
                break;        

        }
        
        return ret;
    }
}
```

위와 같이 팩토리에게 **어느 타입**인지만 알고 있다면 속성 설정을 햇갈릴 일 없이 가장 처음에 작성한 정보로 작성해서 반환해줄 것이다.

`Item potion = Factory.MakeItem("포션");`

그런데 만약 potion의 고유한 기능을 사용하고 싶을수도 있다.

그런 경우에는 두가지 방법이 있다.
단, 두가지 경우 모두 옳지 못한 타입으로의 생산을 요청하면 프로그램이 터질 것이다.

#### 첫번째 방법.
아이템을 받아온 쪽에서 형변환을 시키는 방법이다.
코드는 다음과 같다.

`Potion potion = Factory.MakeItem("포션") as Potion;`

이 방법은 요청하는 측에서 형변환을 하는 방법이므로, 요청자측에서 매번 **as**코드를 작성해야 한다.

이 방법은 호출하는 측에서 번거롭지만 팩토리 내부에서는 오류가 발생하지 않을 것이다.

#### 두번째 방법.
팩토리 클래스를 일반화시키는 방법도 존재한다.
위의 코드를 다음과 같이 수정하는 것이다.
```cs
    class Factory {
        public static T MakeItem<T>(string _type) where T : Item {

            T ret = null;

            switch (_type) {

                case "포션":
                    ret = new Potion() as T;
                    ret.name = "포션";
                    break;

            }

            return null;
        }
    }
```
<br>

뭔가 T로 떡칠이 되어있다.
다만 제약조건에 의해서 T는 Item을 상속받는 객체타입으로만 제한하게 된다.

사용하는 측에서는 코드 변경이 필요 없으나, 만일 잘못된 형변환이 **팩토리의 내부**에서 일어났다면, 제작 요청을 잘못한 코드가 어느 코드인지 찾아내는데 좀 번거로워질 수 있다.

## 빌더 패턴

객체를 생성할때에는 반드시 정의되어있는 생성자의 규칙을 따르게 된다.

그렇다면 구성요소들을 더욱 세분화시킨다음, 구성요소들을 조합하여 여러가지 조합의 객체를 만들수도 있지 않을까?

이러한 장점을 가져갈 수 있도록 작성된 패턴을 빌더 패턴이라고 한다.

<br>
### 동기
<br>
위의 팩토리 패턴을 이해했다면 조금 더 이해하기가 수월할 수 있다.

상술한 팩토리패턴을 현실의 공장에 비유해보면 다음과 같았다.

1. 제작할 제품의 **종류**를 전달받는다.
2. 지정된 **레시피**에 따라 해당 **종류**의 아이템을 만들어서 제공한다.

팩토리 패턴에서는 레시피는 내부 내용을 바꿀 수 없었다.
정확히 말하자면, 레시피를 바꾸면 해당 제품을 만드는 모든 공정에 레시피 변동사항이 적용되는 것이다.

그렇다면 레시피를 여러개 가지고있다가 원본 레시피 요청이면 원본 객체를 만들고, 수정된 레시피 요청이면 수정된 객체를 만들면 되는것 아닌가?

이러한 필요성에 의해 만들어진 패턴이 빌더 패턴이다.
<br>

### 코드 예시
<br>
위에서 말했듯이 레시피 즉, 생성자의 역할을 하는 부분을 종류에 따라 다르게 하고 싶은것이다.

우선 포션에 대한 코드를 잠시 보자.
```cs
class Potion{
    public string name;
}
```
별거 없다. 포션은 이름에 해당하는 name속성만 가지고 있다.

위의 코드는 포션의 구조만 가질 뿐, 생성자가 없다.
따라서 new를 하더라도 name은 공백이 들어가버린다.

그럼 이번에는 레시피에 해당하는 코드를 작성해보자.
```cs
class PotionBuilder{
    private string name = "기본 포션";
    
    public void SetName(string _name){
        name = _name;
    }

    public Potion Make(){
        Potion potion = new Potion();
        potion.name = this.name;
        return potion;
    }

}
```

PotionBuilder 클래스는 레시피 역할을 한다.

이런 식으로 작성을 했다면 다음과 같이 두개의 레시피를 만들 수 있을 것이다.
```cs
PotionBuilder basicPotion = new PotionBuilder();
PotionBuilder highPotion = new PotionBuilder();
hieghPotion.SetName("고급 포션");

basicPotion.Make();  //기본 포션을 반환.
highPotion.Make();   //고급 포션을 반환.
```

이렇게 만들어진 레시피에 제작 요청을 하면, 레시피에 따라 각자 다른 인스턴스들이 나올 것이다.
<br>