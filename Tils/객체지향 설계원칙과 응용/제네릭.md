# 제네릭

우리는 특정 변수를 이야기할 때 타입을 지정해주었었다.
하지만 단순히 더하는 등의 간단한 함수를 작성하는데 매개변수들의 종류의 경우의 수 조합만큼 함수를 오버로드하는것도
상당히 머리가 아플것이다.

이럴 때 유용한 것이 제네릭이다.

<br>

## 제네릭 타입

제네릭 타입이란, 일반화된 타입 즉, 해당 타입에는 일반화된 어느 타입이든 들어올 수 있음을 의미한다.

<br>

### 제네릭 함수의 기본

두 값을 바꾸는 기본적인 제네릭 함수를 작성해보자.

```cs
public void Swap<T> (ref T _val1, ref T _val2){
    T tmp = _val1;
    _val1 = _val2;
    _val2 = tmp;
}
```

기존에 작성하던 매개변수 자리에 T가 왔다.
또 두개의 매개변수의 타입은 T로 동일하다.

이건 무슨 의미를 가질까?

두개의 매개변수는 **같은 타입**이어야 하지만 따로 정해지지는 않았다.
즉, 함수를 호출할 때 **같은 타입**인 두개의 변수를 전달하지만 따로 정해진 타입은 없는 것이다.

아래와 같은 두 호출이 가능하다는 이야기다.

```cs

class MK{}

int intA = 5;
int intB = 10;

float floatA = 2.1f;
float floatB = 4.4f;

MK mk1 = new MK();
MK mk2 = new MK();

Swap(ref intA, ref intB);        // 두 매개변수의 타입은 int, int
Swap(ref floatA, ref floatB);    // 두 매개변수의 타입은 float, float
Swap(ref mk1, ref mk2);          // 두 매개변수의 타입은 MK, MK

//위의 두 함수 모두 각 매개변수의 값을 바꾸는 동작을 한다.
```

<br>

### 타입의 제한

이렇게 대부분의 타입을 받아들일 수 있는 제네릭이지만, 용도에 따라서 제약을 두고싶다.

예를들어 위의 Swap함수를 이용하는데에 있어서, **[값 타입]** 만 이 함수를 이용할 수 있도록 제약사항을 두고싶다고 하자.

이런식으로 입력 매개변수 제네릭 타입에 **제약사항** 을 두는것이 일부 가능하다.

다음과 같이 코드를 수정해보자.
```cs
public void Swap<T> (ref T _val1, ref T _val2) where T : struct{
    T tmp = _val1;
    _val1 = _val2;
    _val2 = tmp;
}
```

함수의 정의 우측에 **where**키워드가 붙고, **T : struct**라는 구문이 생겼다.

여기서 struct는 구조체가 아닌 **값 타입**을 뜻한다.

따라서 이 함수를 이용할 때에는 매개변수 _val1, _val2의 자리에는 **값 타입**의 매개변수만 전달할 수 있도록 제약을 걸어놓은 것이다.

해당 [제약조건] 자리에는 값 타입만을 허용하는 **struct**. 참조 타입만을 허용하는 **class** 두 키워드가 대표적으로 이용된다.
특정 클래스 또는 인터페이스 타입만을 매개변수로 받게 할 수 있으며, 그 때에는 [제약조건] 자리에 클래스명 또는 인터페이스 명을 입력하면 된다.

단, 같은 종류의 제약조건은 하나만 작성할 수 있다.
클래스 A와 클래스 B 두 종류만 받고싶다고 해도 다음과 같은 작성법은 불가능하다는 이야기다.

`where T : A , B`

반대로 서로 다른 종류의 제약조건은 `struct, class`를 제외하면 대부분은 조합이 가능하다.
값타입과 참조타입을 동시에 요구하면 그냥 모든 데이터를 받는다는 뜻이기에 제약이 없는것이나 마찬가지이기 때문이다.

조합된 제약조건의 예시는 다음과 같다.

`where T : classA, ICharacter, new()`

제약조건을 해석하면 classA 타입의 클래스를 상속하고/ ICharacter 인터페이스를 구현해야 하며/ 기본 생성자가 존재해야 한다.
라는 의미를 가진다.

<br>

##### 타입범주가 아닌 특정 클래스 또는 인터페이스로 제한할 경우

인터페이스와 비슷한 역할을 하는데, 특정 클래스 또는 인터페이스임을 확신할 수 있는 경우이기 때문에
매개변수로 들어오는 클래스, 인터페이스에 있는 맴버변수나 함수를 이용하여 기능을 구현할 수 있다.

class 또는 struct로 제약을 건다면 이러한 프로그래밍이 불가능하다.

<br>

## object 타입

c#에는 가장 최상위 부모가 되는 데이터 타입인 **object** 라는 타입이 존재한다.
이 타입은 c#에 존재하는 모든 타입을 포용할 수 있기 때문에 값타입이든 참조타입이든 구조체든 클래스든 뭐든지 담을 수 있다.

그런데 왜 잘 보이지 않는걸까? 한번 살펴보자.

<br>
### 박싱

object 타입은 참조타입이며 구조체, 기본 자료형 등의 값 타입을 object에 넣을 수가 있다고 했다.

하지만 엄밀히 object는 참조타입이라 했으므로 **힙 영역**에 저장되어야 한다.

따라서 **스택 영역**에 있는 값 타입의 자료를 **힙 영역**으로 복사하여 저장하는 과정이 필요하다.

이 작업을 `박싱`이라고 부르며 **꽤나 시간이 걸리게 된다.**

##### 박싱 : 값 타입의 자료형을 참조 타입의 형식으로 변환하여 저장하는 과정.

<br>

### 언박싱

그럼 object타입으로 저장한 타입을 원래 타입으로 돌려놓고 싶다.

그 때에도 참조 타입을 값 타입으로 변환해야 하므로 **힙 영역**의 데이터를 **스택 영역**에 복사해야한다.

박싱과 반대 작업이므로 이 작업을 `언박싱`이라 부르며 똑같이 **꽤나 시간이 걸리게 된다**

또한 큰 단위로의 형변환이 아닌 더욱 세밀한 단위의 타입으로 형변환을 할 때와 마찬가지의 개념으로
잘못된 언박싱이 일어날 수 있다.

예를들어 int형 데이터를 object 타입으로 박싱했었는데, 깜빡하고 해당 데이터를 float형 데이터로 언박싱을 시도하게 된다면
이 데이터는 float타입을 상속한 상태의 데이터가 아니므로 castingexception이 발생하게 된다.

##### 언박싱 : 참조 타입의 데이터를 값 타입의 자료로 변환하여 저장하는 과정.

<br>