# 기타 C# 기능들

이번에는 간단하게 c#에서 제공하는 편리한 기능들이나 지나친 문법들에 대해 살펴보도록 한다.

<br>

## 프로퍼티(속성)

변수를 선언할 때에 보통 공개하거나 제한을 하는 두가지 접근제한을 걸 수 있다.

여기서 변수를 사용할 때에는 파일을 사용할때처럼 두가지 기능을 사용한다.

**읽기**, **쓰기** 두 가지 기능이 있다.

다만 public과 private등으로 접근제한을 설정하게 되면
**둘 다 가능**하게 하거나 **둘 다 불가능**하게 설정이 되어버린다.

만일 **읽는것은 가능**하지만 **수정하는것은 불가능**등의 둘중 하나만 가능하게 변수를 설정하는방법이 없을까?

<br>

### Getter와 Setter

부분적인 기능을 구현하는것은 간단하다. 우선 내부 변수는 반드시 private로 지정한다.

그 뒤에 값을 얻을 수 있는 **Get**함수, 값을 수정할 수 있는 **Set**함수를 작성하는것으로 해결한다.

```cs
private int num;

[public/private] int GetNum(){          // 읽는것이 가능하게 하려면 public, 불가능하게 하려면 private를 작성한다.
    return num;
}

[public/private] void SetNum(int _num){ // 쓰는것이 가능하게 하려면 public, 불가능하게 하려면 private를 작성한다.
    num = _num;
}
```

위와 같이 변수에 대하여 응대하는 함수를 지정해줌으로써 부분적으로 기능을 공개하는 것이 가능하다.

또한, 둘다 공개, 둘다 비공개와 같은 public, private와 같은 기능을 한다고 하더라도, 반드시 해당 함수를 접근해야 하므로
게터와 세터가 함수 콜스택에 쌓인다. 즉, 값이 이상하게 변경되었을 때, 해당 시점을 찾아내는데에 용이하게 사용된다.

<br>

### property

아무리 게터와 세터 함수가 한줄짜리 짧은 함수들이라고 하지만, 변수가 50개라면 함수줄만 최소 100줄...
변수는 50개인데 사용하는 줄만 150개가 된다.

이러한 게터/세터를 간소화시켜서 작성할 수 있도록 프로퍼티라는 기능을 제공한다.

변수를 선언할 때, 다음과 같이 작성하면 된다.

```cs
public int val { [private] get; [private] set; }
```

읽기를 막고싶다면 get의 앞에 private, 쓰기를 막고싶다면 set의 앞에 private를 작성해주면 된다.

다만, 둘 다 동시에 private를 작성하는것은 불가능하다.
그러한 경우에는 그냥 변수를 private로 작성하는것이 더 났기 때문이다.

<br>

### 읽기 전용 반환식

만약 특정한 함수에서 반환되는 결과값이 어떤 의미를 가진다면, 간단한 계산식 또한 읽기전용 변수와 같은 느낌으로 작성해줄 수 있다.

바로 예시를 보면 다음과 같다.

```cs
private int a, b;

public int damage => (a + b);
```

이렇게 작성한다면 외부에서는 다음과 같이 필드를 사용하는것 처럼 접근할 수 있다.

`int getDamage = Player.damage;`

다만, damage는 계산식이므로 다음과 같은 쓰기 연산은 불가능하다.

`player.damage = 5; // 불가능!!`

<br>


## 연산자 재정의

기본 자료형들은 사칙연산을 당연하다는듯이 사용한다.

그렇다면 내가 정의한 자료들도 사칙연산기호를 이용하여 연산할 수 있게 할 수 있을까?

<br>

### 2차원 좌표의 합 구현

직접 사용하기 위해 x좌표와 y좌표를 가지고있는 구조체를 하나 선언했다고 가정하자.

직관적으로 두개의 좌표를 더한다면 x좌표는 x좌표끼리, y좌표는 y좌표끼리 더하는 기능을 추가하고싶다

물론 함수로 구현할 수 있겠지만, 보는 입장에서 직관적이도록 **+** 기호를 활용하고 싶을 때, 다음과 같이 작성할 수 있다.

```cs
public struct Pos{

    public int x;
    public int y;
    
    public Pos(int _x, int _y){
        x = _x;
        y = _y;
    }

    public static Pos operator [+ | - | 등등의 기본 연산자](Pos _a, Pos _b){
        return new Pos(_a.x + _b.x, _a.y + _b.y);
    }

}
```

이렇게 미리 +를 작성했다고 하면 다음과 같은 연산을 할 수 있다.

`new Pos( new Pos(1, 2) + new Pos(3, 4) );`

최종적으로는 x : 4 / y : 6을 가지는 구조체가 만들어진다.

<br>

## Immutable(불변성)

string과 delegate는 참조타입으로 관리되지만 조금 특수한 성질을 가지고있다.
객체가 처음 생성될 때의 상태를 바꿀 수 없는 특징을 가진다.

### string과 메모리

불변성의 특징을 가지는 string을 다룰때에 특히 주의해야 할 사항이 있다.

다음과 같은 코드를 보자.

```cs

string comment = "공부는 어렵다.";

string output = "";

for(int i = 0; i < comment.Length; i++){
    Console.Clear();
    output += comment[i];
    Console.Write(output);
    Thread.Speep(500);
}

```

0.5초마다 한글자씩  comment 의 대사를 출력하는 코드인데 문제는 없어보인다.
그런데 여기에는 메모리적으로 조금 위험한 문제가 발생할 수 있는 코드이다.

조금 알기 쉽도록 비유해서 설명하자면, string은 클래스로 취급되지만, string의 데이터를 변경하는것은
우리가 클래스의 내부 변수를 수정하는것이 아닌 **새로운 string 객체**를 생성해서 가리키는 주소를 바꾸는것이다.

string은 클래스의 타입을 가지지만, 한번 생성되면 내용을 바꿀 수 없고, 바꿔서 할당한다면 값이 바뀌는것**처럼** 보이지만
사실 새로운 데이터가 할당되어서 가리키는 주소를 바꾸는것이다
즉, 이전 객체가 메모리에 남아있는 상태라는 이야기이다.

이 내용을 인지하고 위의 코드를 다시 생각해보자.
문자열끼리 + 연산을 하는것 또한 문자열 객체를 수정하는것이 아니라 새로운 문자열 객체를 생성하는것이다.

다음과 같은 두개의 문자열이 있다고 하자.

`"안녕" "하세요"`

두개의 문자열을 +로 붙인다면 무슨일이 벌어질까?

```cs
string str = "안녕" + "하세요";

//현재 메모리를 점유하고 있는 문자열 상태
//
//1. "안녕"
//2. "하세요"
//3. "안녕하세요" (str에 주소 할당)
```

메모리에는 문자열때문에 할당하는 string 공간이 3개나 필요한것이다.

이쯤되면 comment출력 코드가 얼마나 어지러운 코드인지 머리속에 메모리의 상태와 함께 예상이 갈 것이다.

그렇다면 텍스트 출력 이펙트를 구현하는것은 메모리 폭탄을 감수해야만 할까?

<br>

### StringBuilder

이러한 부담을 조금이나마 덜어주기 위해 c#에서는 StringBuilder라는 클래스를 제공한다.

stringbuilder는 문자열과는 다르게, 문자열을 효율적으로 다루기 위해 구현된 가변 객체이므로, 해당 객체를 생성하여
문자열을 다루게 된다면 문자열이 완성되기 전까지는 가변 객체 형식으로 다루는 방식이 때문에

완성까지의 수정이 많이 걸리는 문자열이라면, 중간 과정에서 생겨나는 문자열 파편들을 신경쓰지 않아도 되기 때문에
메모리 관리에서 더욱 효율적이다.

또한 인스턴스 가변 객체로 취급되기 때문에, 문자열에서 중간에 값을 수정하면 서로 다른 값을 가리키던 문제도 해결된다.

하나의 스트링 빌더 객체를 만들고 여럿이서 공유하고 수정하면, 수정사항 또한 공유한다는 뜻이다.

<br>