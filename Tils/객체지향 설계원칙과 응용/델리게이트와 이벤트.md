# 델리게이트와 이벤트

변수에는 값 타입 데이터와 참조타입 데이터를 저장할 수 있었다.
그런데 주소를 가리킨다면 함수도 가리킬 수 있지 않을까?

이런 개념에서 나온 개념이 델리게이트이다.

<br>

## 델리게이트

위에서 언급했듯이 델리게이트란, 함수를 담을 수 있는 변수이다.
반응형 프로그래밍 또는 콜백함수를 구현하는데에 자주 사용된다.

또한 함수의 주소를 가리키는 참조타입 데이터이다.

<br>

### 델리게이트 타입의 선언

델리게이트 형 변수를 사용하기 위해서는 델리게이트가 어떤 형식의 함수를 저장할 수 있는지
미리 함수형의 정의를 해 줄 필요가 있다.

값 타입 변수로 치면 struct의 구조를 처음 정의하는것 과 같다.

델리게이트의 선언은 다음과 같이 이루어진다.

```cs
[접근제한자] delegate void SimpleDel_1();        // 반환값이 없고 매개변수도 없는 함수를 저장할 수 있는 데이터 타입.
[접근제한자] delegate int SimpleDel_2(int _val); // int형 데이터를 반환하고 int형 데이터를 매개변수로 필요로 하는 함수를
                                                // 저장할 수 있는 데이터 타입.
```

<br>


### 델리게이트의 데이터 지정

구조체의 구조 정의가 끝났다면, 이제 값을 저장해야 한다.
똑같은 방식으로 델리게이트 변수를 만들고 데이터를 지정해보자.

```cs
public delegate void Simple(); // 정의

void func(){
    Console.WriteLine("출력!");
}

void func2(){
    Console.WriteLine("출력2!");
}


//======================

Simple delName = func;    // 위에 func() 함수 참조를 저.

delName = func2;          // delName에 func 대신 func2 참조를 덮어씌움

delName += func;          // delName에 func2와 더불어 func를 추가 저장함

delName -= func2;         // delName에 저장되어있는 함수 참조들 중, func2만을 저장 해제함.

```

저장에 관련된 연산자는 **=**, **+=**, **-=** 세가지 종류가 있다.

**=** : 델리게이트 변수에 함수를 할당한다. 기존 저장되어있던 함수들을 전부 제거하고 덮어쓴다.
**+=** : 델리게이트 변수에 함수를 **추가** 할당한다. 기존 저장되어있던 함수들의 참조도 그대로 유지한 채로 추가된다.
**-=** : 델리게이트 변수에 등록되어있는 함수 참조들 중, 전달받은 함수 참조만을 **참조 해제**한다. 그 외의 함수들의 참조는 유지되며,
제거할 함수가 존재하지 않는다면 아무런 일도 하지 않는다.

<br>

### 사용법과 Invoke

변수를 담았으니 이제 사용해야겠다. 사용법은 또 간단하다. 반환값과 매개변수가 통일되어있는 함수가 모여있는 변수이므로
반환값이 있으면 받고 매개변수가 있으면 전달하면 된다.

만일 여러개의 함수가 저장되어 있다면, 저장된 함수들을 모두 실행한다.
같은 함수가 여러번 등록되어있다면, 등록된 횟수만큼 반복실행시킨다.

단, 반환값이 있는 함수가 여러개 등록되어있으면, 반환값은 한개만 받을 수 있게 되므로 반환값이 있는 델리게이트는
하나의 함수만 저장하는것이 사용상 오류를 발생시키지 않는다.

호출하는 방식은 다음과 같다.

```cs
delName(); // 괄호 안에는 매개변수를 작성한다.
delName.Invoke(); // 둘 다 같은 동작을 한다.
```

두가지 방법 모두 같은 결과를 나타낸다.
단, Invoke의 경우 **?** 를 사용한 유효성 검사도 할 수 있다.

사용법은 아래와 같다.

```cs
delName?.Invoke();
```

이렇게 코드를 작성하면 델리게이트를 실행하기 전에 등록된 함수가 있는지 먼저 확인한다.
당연스럽게도 함수가 아무것도 저장되어있지 않다면, 실행할수도 없기 때문이다.

그렇게 함수가 없다면 실행하지 않고, 함수가 있는 경우에는 해당 함수들을 실행하게 만드는 검사문이다.

<br>

## 이벤트

델리게이트의 가장 유용한 활용법중 하나는 이벤트 구조를 설계하는 일이다.
그렇다면 이벤트 구조란 뭘까?

간단하게 설명하고 문제점과 해결방법에 대해 알아보자.

<br>

### 이벤트의 구조

게임 캐릭터가 존재하고 있다. 그런데 게임 캐릭터가 언제 게임오버가 되는지는 전적으로 플레이어의 역량이나
행동 방식에 달렸다.

즉, 언제 플레이어가 죽을 지 모른다는것이다.

그런데 플레이어가 죽는 순간, [죽었다는 메세지를 띄우고], [게임오버 음악을 플레이]하고 싶다.

이러한 **특정 트리거 이벤트** 가 발생했을 때, 실행될 기능들을 등록해놓고, 
**이벤트가 발생한 순간** 해당 기능들을 실행하는 구조를 말한다.

<br>


### 이벤트의 설계

이벤트의 구조를 알았으니 이는 코드로 옮길수 있다.
구현하는 방식은 델리게이트와 델리게이트 체인을 이용하여 작성할 수 있다.

다음과 같이 작성해보자.

```cs

class Player{

    public Action onDied;    // 실행할 행동들을 등록할 델리게이트

    private void Die(){      // 플레이어가 죽으면 플레이어가 실행할 함수블록
        onDied?.Invoke();    // 등록된 이벤트들 호출
    }

}

class Ui{
    public void ShowDieUi(){ // 죽음 ui 출력 }
}

class Sound{
    public void PlayDieSnd(){ // 죽음 사운드 출력 }
}


class Program{

    static void main(){
    
        Player player = new Player();
        Ui ui = new Ui();
        Sound sound = new Sound();
        
        player.onDied += ui.ShowDieUi;
        player.onDied += sound.PlayDieSnd;

    }

}


```

플레이어 객체는 본인이 죽었다는것만 알릴 뿐, 그 이후에는 무슨일이 일어나는지 모른다.
이후에 일어나는 일은 플레이어는 아무것도 모르고, 플레이어의 죽음이 일어나는 순간 발생하도록 등록한 함수 묶음들인
onDied 델리게이트 변수에 있는 함수들을 호출할 뿐이다.

<br>


### 설계구조적인 문제

기능적으로나 문법적으로나 위의 이벤트 코드는 무사히 동작한다. 하지만 설계론적의 관점에서 몇가지 문제를 가진다.

##### 문제 1 : onDied를 외부에서 호출 가능하다.
<hr>

단순하게 생각해서 onDied는 플레이어가 죽었을 때 기능할 함수들을 저장해놓은것이다.
하지만 논리적인 구조상으로 플레이어가 실행시킬 뿐, 다른 객체나 외부에서 실행이 불가능하다는것은 아니다.

시스템적으로 제한된 행동이 아니기 때문에 메인함수에서 이러한 일을 벌일수도 있다.

```
class Program{

    static void main(){
        //...생략...
        
        player.onDied(); // 플레이어가 죽었든 안죽었든 죽었을 때 일어나는 일들을 발생시키겠다!!!!!
    }

}
```

뭔가 논리적으로는 일어나면 안되는 구조의 흐름이다.
플레이어가 본인이 죽은걸 인지하고 이후 행동들을 묶어놓은 함수를 호출해야하지만,
죽든말든 이 함수묶음을 외부에서 실행시킬 수 있다는 점이다.

그렇다고 이 델리게이트를 private로 만들어놓자니 외부에서 접근이 불가능하므로 함수에 등록, 삭제등을 할 수 없다( += / -= )

<br>

##### 문제 2 : 휴먼 에러의 문제

플레이어가 죽었을 때에 발생할 현상들은 보통 여러가지가 하나의 델리게이트에 담긴다.
그런데 델리게이트에 대해 배울때 = 연산과 += 연산은 상당히 다른 의미를 가진다는것을 배웠을 것이다.

자, 위의 코드에서 플레이어가 죽었을 때, 카메라가 [페이드 아웃] 하는 기능을 델리게이트에 추가한다고 생각해보자.

```cs
class Program{

    static void main(){
    
        Player player = new Player();
        Ui ui = new Ui();
        Sound sound = new Sound();
        
        player.onDied += ui.ShowDieUi;
        player.onDied += sound.PlayDieSnd;
        
        Camera camera = new Camera();
        player.onDied = camera.PlayFadeOut;

    }

}

```

얼핏보면 문제 없고, 문법적으로도 오류를 발생시키지 않는다. 하지만 자세히보면 페이드 아웃 기능을 추가 등록할 때 **=** 연산자를 사용해버렸다.
이는 기존까지 등록된 기능들을 완전히 다 지워버리는 참사를 만들어버린다.

다른 담당자들은 갑자기 기능이 실행되지 않는것을 보고 뭐가 문제인지 머리가 아파지기 시작할것이다.
단순히 카메라 담당자가 +를 빼먹은것 하나때문에 말이다.

말도안된다고 생각할 수 있지만, 우리는 어느 부분이든 실수할 수 있다. 그리고 또 할것이다.

<br>

### event

상술한 두가지 문제점을 해결하기 위해 나온 키워드가 **event** 키워드다.

키워드의 이름으로부터 알 수 있듯이. 위의 이벤트 설계 구조를 목적으로 만들어진 기능이다.

사용방법은 단순하다. 델리게이트 변수를 만들 때, delegate타입 앞에 event라고 명시해주면 된다.

`public [event] [definedType] [변수명]`

예시에는 action 키워드를 사용했지만, action은 미리 정의되어있는 델리게이트이므로 이후에 설명한다.
미리 정의되어있는 action 타입의 델리게이트라고 이해하고 넘어가도 좋다.

그럼 event키워드를 붙이면 코드에 어떤 변화가 일어나느냐?
위에서 발생한 두가지 문제점을 해결해준다.

```cs

class Player{

    public event Action onDied;    // 이벤트 타입 델리게이트로 변경

    private void Die(){      
        onDied?.Invoke();    // 오류 x
    }

}

// ..생략..

class Program{

    static void main(){
    
        Player player = new Player();
        Ui ui = new Ui();
        Sound sound = new Sound();
        Camera camera = new Camera();
        
        player.onDied += ui.ShowDieUi;
        player.onDied += sound.PlayDieSnd;
        
        player.onDied(); // event타입이므로 외부에서 호출 불가! 에러 발생!
        
        player.onDied = Camera.PlayFadeOut; // event타입이므로 = 연산 사용 불가! 에러 발생!

    }

}


```

event 키워드 하나를 추가해줌으로써 문법적으로 두가지 경우를 사용할 수 없도록 제약한다.

따라서 이벤트 구조를 설계할 때에는 event 키워드를 사용하는것이 좋다.

<br>


## 제네릭 델리게이트

델리게이트를 통해 함수를 저장할 수 있다는 사실을 알았다. 그런데 사실 구조체와는 다르게
함수의 정의 구조는 일반화될 수 있다.

이 말은, 제네릭으로 뼈대를 구성해놓는다면, 구조체처럼 굳이 사용할 때마다 정의를 해줄 필요가 없다는 뜻이 된다.

정리하면, 우리가 int, float등을 사용할 때 미리 정의가 되어 있기 때문에 바로 선언하고 사용하는것 처럼
함수의 형식도 제네릭으로 일반화하여 미리 정의해둘 수 있기 때문에 제네릭 델리게이트를 이용하면
델리게이트 타입을 정의하지 않고 선언부터 시작하여 사용할 수 있다.

<br>

### Action

제네릭 델리게이트에서 함수는 다음 기준에 따라 두가지 종류로 나뉜다.

`반환값의 존재 여부`

우선 반환값이 없는 델리게이트 형태인 Action을 알아보자.

다음과 같은 코드를 보자.

```cs
public delegate void Simple(); // 정의.
Simple delName = func;         // 선언 및 할당.
delName?.Invoke();             // 함수 실행.

void func(){ // 반환값이 없는 함수 정의부
    Console.WriteLine("출력!");
}
```

사실 위의 코드에서 함수의 정의 방법은 한정되어 있기 때문에 정의부를 생략하고 통일시킬 수 있다.

그 중 Action의 타입 정의는 다음과 같다.

`Action [변수명]` 또는 `Action<[매개변수1], [매개변수2] ....>`

그냥 자료형인 int형같은 사용법이 된다.

이를 이용하여 위의 코드를 수정하면 다음과 같다.

```cs
Action delName = func;         // 선언 및 할당.
delName?.Invoke();             // 함수 실행.

void func(){ // 반환값이 없는 함수 정의부
    Console.WriteLine("출력!");
}
```

위의 정의부가 사라졌음을 알 수 있다.

만일 매개변수가 있는 Action 델리게이트일 경우 다음과 같이 작성하면 된다.

```cs
Action<int> delName = func;    // 선언 및 할당.
delName?.Invoke();             // 함수 실행.

void func(int _val){ // 반환값이 없고 매개변수가 있는 함수 정의부
    Console.WriteLine(_Val);
}
```

<br>

### Func

그렇다면 반환값이 있는 함수의 정의 형태도 일반화되어 있을까?
Func타입을 이용하면 된다.

Func타입은 반환값이 존재하고, 매개변수 또한 사용이 가능하다.

Func타입의 정의는 다음과 같다.

`Func< [매개변수1], [매개변수2], ........ (반환값 타입)>`

여기서 매개변수 타입은 함수를 정의할 때의 순서와 같다.
호출할 때에도 정의할 때의 매개변수의 순서를 따라서 전달해야 제대로 작동한다.

다만, 반환값이 반드시 존재하는 함수의 일반화이므로 매개변수를 의미하는 변수 타입이
가장 **마지막** 부분의 타입이 그 역할을 한다.

이는 생략할수가 없으므로 반드시 <> 안에는 반환값의 역할을 할 타입이 하나는 들어가있게 된다.

이전과 같이 코드를 수정해보자.

```cs
public delegate int Simple(int _val, string _str); // 정의.
Simple delName = func;                             // 선언 및 할당.
delName?.Invoke(10, "출력합니다!");                 // 함수 실행.

int func(int _val, string _str){                   // 반환값과 매개변수가 있는 함수 정의부
    Console.WriteLine(str);
    return _val * 2;
}
```

바로 적용해서 수정해보자.

```cs
Func<int, string, int> delName = func;             // 선언 및 할당.
delName?.Invoke(10, "출력합니다!");                 // 함수 실행.

int func(int _val, string _str){                   // 반환값과 매개변수가 있는 함수 정의부
    Console.WriteLine(str);
    return _val * 2;
}
```

<>안에 두개의 매개변수 **int, string** 을 순서로 넣어주고, 마지막에는 반환값인 **int**형을 작성해 델리게이트를 선언한다.
사용할때에도 매개변수에 해당하는 변수 타입들을 선언시의 순서 그대로 넣어주면 제대로 작동한다.

<br>