# 버전 관리

협업 환경에서 또는 코드의 백업등이 필요할 때에 단계마다 프로젝트를 저장하기에는 용량에 한계가 있다.
이 문제를 어떻게 해결할 수 있을까?

<br>

## Git

가장 대중적이고 오래 사용된 형상 관리를 지원하는 도구이다.

프로젝트들을 지점별로 백업하여 이전 저장 시점으로 옮길 수도 있고
원격 저장소에 저장되어있기 때문에, 계정 연동만 되어 있다면 다른 기기에서도
똑같이 프로젝트를 바로 받아서 사용/수정할 수 있다.

<br>

### 리모트 저장소 ( remote repository )

프로젝트 관련 파일과 코드가 실제로 저장되어 있는 저장소이다.
형상관리 서비스를 지원하는 곳의 데이터서버에 저장되어 있으며
프로젝트의 원본과 단계별 백업본, 분기시점의 코드등이 저장되어 있는 곳이다.

<br>

### 로컬 저장소 ( local repository )

현재 사용하고 있는 기기의 저장소를 의미하며 로컬 저장소로 지정된 곳의 파일들이
수정/생성/삭제 등의 변화가 일어나면 이를 인식하여 리모트 저장소에 적용할지 결정할 수 있다.

이 곳에서 파일이 사라져도 리모트 저장소에는 영향이 없으므로 돌발사항에 효율적으로 대비할 수 있다.

<br>

## git 용어

git을 사용하기 위해 이용되는 용어들과 사용법에 대해 알아보자.

<br>

### add와 commit

로컬 저장소 환경에서 파일의 수정이 일어났다고 해서 수정된 모든 파일들을 적용시키지는 않아도 된다.
어떤 파일을 적용하고 적용하지 않을것인지 선별하는 과정을 **add** 라고 한다.

add를 통해 수정사항을 적용할 파일의 선별을 마쳤다면, 수정된 사항들을 묶어서 하나의 버전으로 만드는 과정이 필요하다
이를 **commit** 이라고 하며, commit을 할 때에는 **commit의 이름** , **commit의 상세 내용** 을 작성해야 한다.

<br>

### discard

**add** 될 항목을 선택할 때 항목을 클릭하면 변경된 사항이 보인다. 이때 해당 항목을 우클릭 한뒤 discard를 누르면
해당 파일을 **변경 전** 상태로 되돌려놓는다. 로컬 저장소의 파일이 변하므로 수정사항을 되돌리고 싶지 않다면
조심해야 한다.

<br>

### check out

**commit** 되어있는 목록들 중에 이전 상태로 잠시 돌아가보고싶을 경우에 history에 있는 commit 목록들 중
잠시 되돌아가고싶은 commit항목에 우클릭을 한 뒤 **check out** 항목을 누르면 모든 로컬 파일을 그 시점으로
되돌릴 수 있다.

다시 최신 상태로 돌아가려면 되돌아간 시점에 해당되는 브랜치를 **current branch** 항목에서 선택해주면 된다.

<br>

### gitIgnore

깃의 특수한 문서이며, 해당 파일 안에 폴더 경로, 확장자명 등을 작성해준다면 change를 트래킹할 때 해당하는
파일들의 수정사항들을 추적하지 않고 무시한다.

<br>

### push

로컬 저장소에 완료된 **commit** 이 존재한다면, 이제 리모트 저장소에 저장할 차례이다.

이렇게 commit된 사항들을 버전별로 등록하여 리모트 저장소를 갱신하는 행위를 **push** 라고 한다.

즉, **commit** 만 한 뒤에 **push** 를 하지 않으면 서버에 변경사항이 적용되지 않는다.

<br>

### clone

로컬 작업 환경에 원하는 리모트 저장소에 대응하는 로컬 저장소가 존재하지 않는 경우

대응되는 로컬 저장소를 새로 생성한 뒤, 리모트 저장소에 있는 파일들을 다운로드 하는 과정이다.

리모트 저장소에 있는 프로젝트를 최초로 가져올 때 이용하는 기능이다.

<br>

### fetch

현재 로컬 저장소에 적용되지 않은 리모트 저장소의 최신 수정사항이 있는지 확인하고, 수정사항이 존재한다면
이를 알리고 해당 항목들을 보여주는 역할을 한다.

<br>

### pull

fetch를 이용하여 최신화 할 항목들을 선택한 뒤, 해당 파일들을 최신화 된 파일들로 업데이트 즉, 가장 최신 파일들로
덮어쓰기, 제거, 생성 등을 하는 기능이다.

단순히 로컬 저장소를 최신 버전으로 업데이트 하는 과정이다.

<br>

## conflict

형상관리 도구에서 가장 중요한 부분 중 하나이다.

여럿이서 협업하는 프로젝트에서는 서로 다른 다수의 사람이 리모트 코드의 같은 부분을 다른 내용으로 수정했을 때
**충돌** 이 일어난다.
<br>
```cs
Console.WriteLine("원본 출력부");
```

위와 같은 원본 리모트 코드를 두명의 사람이 각자 다음과 같이 수정했다고 해보자.
<br>
```cs
Console.WriteLine("A라고 출력하고싶어!"); // A가 수정함.

=========================================================같은 시간 A, B가 동시에 수정

Console.WriteLine("B는 B이다."); // B가 수정함.
```

어느 순서로 push를 하더라도 결국 같은부분에 대한 수정 의견이 충돌하였으므로 이는 컴퓨터가 어느쪽이 좋은지
자동으로 판단할 수 있는 부분이 아니기 때문이다.

이러한 충돌이 일어난다면 대부분의 형상관리 도구는 나중에 push하는 사람에게 충돌이 일어났음을 알려주고
충돌한 부분을 보여준다.

예를 들어, github desktop에서는 다음과 같이 보여준다.

```cs
<<<<<< HEAD
Console.WriteLine("A라고 출력하고싶어!"); // A가 수정함.

======

Console.WriteLine("B는 B이다."); // B가 수정함.
>>>>>>> 3847a35ef32d4f3//커밋 코드
```

HEAD와 ===== 사이 부분이 본인의 코드, 그 아래의 코드가 리모트 코드에서 충돌이 발생한 코드이다.

두 코드 중 어느 코드가 개발 의도에 맞는지 서로 상의하고 합의하고 판단하게 하여 개발 방향에 맞는 코드를 선택하게 만든다.

<br>

## branch

형상관리 도구에서 가장 중요한 또다른 부분 중 하나이다.

많은 사람들이 동시에 개발을 하다보면 하나의 파일에 계속해서 수정을 거치다보면 충돌이 발생할 가능성이 매우 높아진다.
게다가 대부분의 개발 환경은 개발 인원이 각각 개발 범위를 겹치지 않도록 개발하기 때문에 하나의 개발 줄기만 가지고 개발하게 된다면
계속해서 관련도 없는 fetch & pull 을 수시로 하는 상황이 발생하고 심심하면 충돌이 발생하고 할 것이다.

그렇다면 이 개발 줄기를 개발 영역만큼 여러개로 나눈 뒤에 병렬적으로 개발한 후, 한번에 합치는것이 더욱 효율적일 것이다.

이런식으로 나누어진 각각의 개발 줄기를 **branch** 라고 부른다.

**branch** 의 또다른 장점은, 대부분 기능별로 branch를 나누어 놓기 때문에, 병합 흐름을 보면서 각 분기가 어느정도 개발 진척도를 가지고 있고
어느 방식으로 병합되고있는지 한눈에 개발 흐름을 파악할 수 있다는 장점이 있다.

<br>

### branch의 명명 규칙

branch를 생성할 때 해당 줄기가 어떤 목적으로 생성되어있는지 모호할 수 있다.
이를 위해 암묵적인 규칙으로 후술할 commit message의 헤더 타입을 이용한다.

예를들어 몬스터의 기능 개발을 위한 줄기의 이름은 다음과 같이 짓는다

##### feat/Monster

더욱 세세한 줄기를 나누고 싶다면 해당 줄기에서 계속해서 분기해 나갈 수 있다.

##### feat/Monster/Attack
##### feat/Monster/Move

<br>


### marge

나누어서 개발했으면 언젠가는 하나의 프로젝트로 합치고 개발을 마무리 해야 한다. 
따라서 분기만큼 중요한것이 병합이다.

충돌(**conflict**)이 발생하지 않는다는 가정하에 병합은 매우 간단하다.

<br>

우선 나누어졌던 분기가 합쳐질 **큰 줄기** 의 branch로 이동한다.

상위 branch로 이동한 상태에서 병합할 하위 줄기를 선택하여 **병합한다** ( 상황에 따라 병합 요청을 보내고 기다리기도 한다.)

충돌이 발생한다면 상술한 **conflict** 항목의 절차에 따라 충돌을 해결한다.

더 이상 문제가 없다면 병합이 완료되며 분기했던 branch는 제거한다.

<br>

### pull request

위와 같이 혼자서 하는 프로젝트가 아니여서 병합하는데에 결정권자의 승인이 필요한 경우 병합 요청을 보내야 한다.

이럴때에 pull request를 보내게 된다.

간단하게 어느 branch를 어느 branch에 병합하기 원하는지를 명시하고 요청 메세지를 작성하여 요청을 보낼 수 있다.

이렇게 요청이 발생하면 결정권자와 구성원들이 상의하여 병합 승인 여부를 결정하게 된다.

<br>


## Commit의 명명규칙 [ git 메시지 규칙 ]

필수는 아니지만 commit이 많아질수록 어느 부분을 어떤 목적으로 수정했는지 알아보기 어려울 가능성이 높다.

후일을 위해서라도 후술할 commit message 규칙을 지킬 것을 **강력히 권장** 한다.

<br>

### Commit 메시지의 7규칙
<br>
##### 1. 제목과 본문을 빈 행으로 구분한다.
##### 2. 제목은 50글자 이내로 제한한다.
##### 3. 제목의 첫 글자는 대문자로 작성한다.
##### 4. 제목 끝에는 마침표를 넣지 않는다.
##### 5. 제목은 명령문으로 사용하며 과거형을 사용하지 않는다.
##### 6. 본문의 각 행은 72글자 내로 제한한다.
##### 7. 어떻게 보다는 무엇과 왜를 설명한다.

<br>

**제목** : 50글자 이내로 **과거형 X** , **명령문** 으로 작성. ex )~~제작 / ~~추가 ...
**본문** : 어떻게 구현했는지보다는 **무엇** 을 만들었으며 **왜** 개발했는지를 위주로 작성한다.

<br>

### Commit 메시지의 타입

commit메시지를 작성할 때 특히 제목의 앞에 **커밋 타입** 을 작성하여
어떤 이유의 commit인지 직관적으로 알아볼 수 있게 한다.

```
feat : 키보드 입력

사용자의 키보드를 통한 입력을 input클래스를 이용하여 구현
상하좌우 화살표 입력을 받아 이동을 구현하기 위해 작성
```
위처럼 **< type > :** 과 같이 접두어를 붙여 commit 제목을 작성한다.

<br>

**대부분의 환경에서 암묵적으로 사용하는 접두어는 다음과 같으며, 협업하는 그룹 또는 조직에서 협의한 접두어를 사용해도 괜찮다.**


|접두어 종류  | 커밋 내용  |
| --- | --- |
|feat	  |새로운 기능에 대한 커밋  |
|fix	  | 버그 수정에 대한 커밋 |
|build	  | 빌드 관련 파일 수정 / 모듈 설치 또는 삭제에 대한 커밋 **[ ex) 해상도, 물리엔진 로직 검사 주기 등등 ]** |
|chore	  | 그 외 자잘한 수정에 대한 커밋 |
|ci  |  ci 관련 설정 수정에 대한 커밋|
| docs	 | 문서 수정에 대한 커밋 |
| style	 | 코드 스타일 혹은 포맷 등에 관한 커밋 |
|refactor	  |코드 리팩토링에 대한 커밋  |
|test	  |테스트 코드 수정에 대한 커밋  |
|perf	  |성능 개선에 대한 커밋  |

<br>

