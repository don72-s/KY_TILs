# Astar 알고리즘

경로탐색에 있어서 가장 유명한 알고리듬은 다익스트라 알고리듬이다. 또한 유니티 3D에서는 NavMesh를 사용하기도 했었다.

하지만 2D나 인공지능의 길찾기에서는 A*알고리듬이 더 효율적인 경우가 많다.

이 알고리듬이 뭐길래 자주 사용하는걸까?

<br>

## 개방맵의 탐색

다익스트라 알고리듬은 분명 효율적인 알고리듬이지만, 개방되어있는 맵에서는 상당한 연산 손실이 있다.

그 이유는 무엇일까?

<br>

### 완벽한 너비우선 탐색

개방맵 즉, 단적으로 표현해서 타일맵에서 최단거리를 찾게 된다면, 다익스트라 알고리듬은 **현재 상황**에서 가장 비용이 적게드는 **방문하지 않은 인접노드**를 탐색하게 된다.

따라서 3칸 앞에 목적지가 있음에도 불구하고, 전방위로 천천히 탐색하게 된다.

따라서 개방된 타일맵에서 다익스트라 탐색을 진행하게 된다면, 분명 직선거리로는 n이 나오는 최단거리이지만 그것을 찾기 위해서 n^2의 탐색 연산을 하게 된다는 것이다.

<br>

### greedy(욕심쟁이)와 추정

조금만 더 단순하게 생각해보자. 우리는 직관적으로 목적지까지의 방향을 알고있기 때문에 해당 방향으로의 탐색이 효율적이라는것을 직관적으로 알고있다.

하지만 컴퓨터는 그런것을 모른다. 그렇기에 전방위적으로 탐색을 하는것이다.

그렇다면 컴퓨터에게 현재 탐색이 가능한 노드들에 대하여 **목적지에 더 효율적으로 도달할 수 있을것 같은 수치**를 제공할 수 있다면, 더 효율적인 노드를 우선적으로 탐색하게 될 것이다!

이렇게 현재상황에서 바로 이득이 되는 노드만 선택하여 탐색하는 방식을 Greedy 알고리듬이라고 한다.

<br>
### 추정값 (heuristic) 또는 예상 비용

다만 목적지와의 효율적인 추정비용을 추측해내기 위해서는 한가지 조건이 있다.

목적지까지의 비용을 예상할 수 있는 기준이 있어야 한다.

즉, 목적지를 정확히 알고, **각 노드로부터 목적지까지의 비용을 일관적으로 예상할 수 있어야 한다.**

특정 노드에서의 예상 비용이 계속해서 변한다면 이는 합리적으로 추측했던 이전 추측값이 무용지물이 되기 때문이다.

<br>

## A* 기본

다익스트라 알고리듬의 원리와 문제점, 그리고 개선 아이디어를 알아봤다.

위의 요소들을 합하여 만들어진 알고리듬이 `A*`알고리듬이 되겠다.

<br>

### 비용 산출의 기본

A* 알고리듬은 크게 3가지 요소로 이루어진다.

- F : 예상되는 최종 비용
- G : 해당 노드까지 소요된 **현재 비용**
- H : 해당 노드부터 목적지까지 예상되는 **예상 비용**

위와 같이 3가지 요소에 기반하여 길찾기가 이루어지며, 서로의 관계는 다음과 같은 수식으로 표현된다.

`F = G + H`

따라서 모든 노드는 3가지의 값을 가지고 있으며 결론적으로는 주변 노드들 중에 **F**가 가장 작은 노드를 우선적으로 선택하여 탐색하게 된다.

<br>

### G와 H

F를 알기 위해서는 G와 H를 알아야 한다.

H의 값은 **기준 휴리스틱**이 정의된 순간 **절대로**변하지 않는다.

예측 기준이 바뀌지 않는다면, 예상 비용은 당연히 바뀔일이 없기 때문이다.

의외로 다음 노드를 선정할 때 신경써야하는 요소가 **G**이다. 

특정 노드까지 도달하는 비용인 G는 도달하는 경로수만큼 존재하기 때문이다.

따라서 노드를 선택하기 전에, 주변에 탐색 대상이 된 노드들에게 가장 적게드는 G를 지정한 뒤, 노드를 선택할 필요가 있다.

<br>

### 최단 경로의 출력

기준에 따라 계속해서 변하는 선택 노드, 다익스트라 기반 경로탐색에서 예상할 수 있듯이, A*알고리듬 또한 최종 경로를 한번에 출력할 수 있는 알고리듬은 아니다.

따라서 **각 노드가 어느 노드로부터 방문되었는지**를 알고 있어야 하며, 도착한 목적지부터 이전 방문 노드를 연쇄적으로 출력하며 최단경로를 알고있어야 하는 것이다.

따라서 각 노드는 Parent Node에 해당하는 데이터도 가지고 있어야 할 것이다.

<br>

## A*의 동작

원리를 알았으니 노드 데이터의 구성부터 동작 로직을 의사코드로 간단하게 알아보도록 하자.

<br>

### 노드의 데이터구조

노드가 가지고있어야 하는 데이터는 위에서 다 설명했다.

다만, 비교연산이 자주 일어나기때문에 비용에 관련된 변수들은 **정수형**으로 작성하는것이 정확성을 높이는 방법이 된다.

따라서 , 비용이 실수로 나타난다면 **10의 단위를 곱하여 정수 자료형으로 만들어 비교하는것**이 연산량과 정확성에서도 효율적일 것이다.

또한, 다익스트라 알고리듬의 원리에 기반을 두고있으므로, 한번 탐색이 완료된 노드는 다시 선택되면 안된다.
이를 위한 bool 변수도 하나 추가해준다.

설명에 따른 각 노드의 데이터 구조는 다음과 같다.

```cs
class Node{
    public int totalCost = int.MaxValue;  //f
    public int curCost = int.MaxValue;    //g
    public int predictCost = int.MaxValue;//h
    
    public Node parentNode = null;
    
    public bool isVisited = false;
    public bool isClosed = false;
}
```

<br>

### 휴리스틱을 구하는 함수

각각 노드의 휴리스틱은 변하지 않지만 그렇다고 존재하는 모든 노드의 휴리스틱을 먼저 구한 뒤 탐색을 하는것은 비효율적이다.

따라서 h의 초기값을 int.MaxValue등으로 지정해놓은 뒤, 처음 h에 접근할때에 한해서 h값을 추정해서 넣어주는 방식을 사용해야 한다.

<br>

### 진행과 의사코드

탐색 방법은 다음과 같은 의사코드의 반복을 따른다.

```cs
시작 노드 g = 0, h = GET, f = g + h, isvisited = true, isclosed = true

list 열린 노드들.add(시작노드)

while(열린 노드들 > 0){
    탐색대상노드 = 열린 노드들 중 f이 가장 작은 노드, f가 같다면 g가 더 큰걸 우선 선택
    
    if(탐색대상노드 == 도착노드)
        break;
    
    열린노드들.remove(탐색대상노드);
    
    for (n 탐색대상노드에서 갈수있는 모든 열린 노드들){
    
        if(n.h == int.maxValue)
            n.h = 휴리스틱 값 할당

        n.g => min[n.g, 현재노드g + 현재노드에서 대상노드까지의 이동비용.
        
        최소값이 갱신되었다면 n.parent = 현재노드
        n.f = n.g + n.h ( g가 갱신된 경우 )

        if(!n.isvisited){
            n.isvisited = true;
            열린노드들.add(n);
        }

    }
    
    탐색대상노드.isclosed = true;

}

if(목적지노드.isclosed){
    list 경로
    노드 = 목적지노드
    while(노드.parentNode != null){
        경로.add(노드)
        노드 = 노드.parentNode;
    }
    
    return 경로.inverse;
}

return null;

```

조금 복잡하고 두서없이 작성되었지만 원리만 생각하며 천천히 살펴보자.

1. 시작지점을 열린 노드들에 넣어준다.
2. 열린 노드들이 빌 때까지 계속 반복한다(열린 노드가 빈다면 도달가능 경로가 없는것.)
3. 열린 노드들 중, f가 가장 작은것을 선정한다.
4. 선정된 노드가 목적지 노드라면 반복을 종료하고 10번으로 이동한다.
5. 선정된 노드들로부터 갈 수 있는 노드들 중에 닫힌 노드가 아닌 노드들을 찾아낸다.
6. 찾아낸 노드들을 기준으로 그 노드들의 g와 현재 노드의 g + 해당 노드까지의 이동비용 중, 후자가 더 작다면 갱신한다.
7. 갱신할때에는 대상 노드의 부모를 현재 노드로 바꾸어준다.
8. 만일 첫 방문이라면 h를 계산해준 뒤, 열린 노드 리스트에 넣어준다.
9. 탐색한 노드를 닫아준 뒤, 2번으로 돌아가 탐색을 반복한다.
10. 도착지 노드로부터 null을 반환할때까지 parentNode를 출력한다.
11. 출력된 경로를 역순으로 재출력한다.
12. 최단경로 탐색이 완료된다.

<br>

### 대각선 탐색

사실 위의 코드는 의사코드이기 때문에 이동가능여부, 휴리스틱에 따라 작성하기만 하면 된다.

사방만 움직이는것이 가능할 경우, 주변 노드 이동가능 확인일 때 상하좌우노드, 기본이동 g를 이용하여 계산하면 될 것이고

대각선이동을 탐색할 경우, 사선 노드, 사선이동g를 적용하여 계산하면 될 것이다.

이에따른 휴리스틱을 맞춰서 제공해준다면 위의 로직을 벗어나지 않게 될 것이다.

<br>

## 개방형 맵과 고립

출발지에서 도착지까지의 이동가능 경로가 없는 경우에는 어떤 일이 발생할까?

기본적으로 두가지 상황을 가정하게 된다.

1. 열린 노드들이 하나도 남지 않은경우.
2. 개방형 맵이라 무한루프를 도는 경우.

1번에 해당하는 경우는 출발지가 벽으로 막혀있어서 이론상으로 열린 노드 리스트가 언젠가는 비게 되는 경우가 된다.

목적지에 도달할 수 있든, 없든, 외벽으로 둘러싸여있을 경우 반드시 해당 상황으로 수렴하게 된다.

다만 2번의 경우 문제가 된다.

외벽이 없는 개방형 맵에서 목적지가 고립되어있는 상태라면 열린 노드가 비는일이 없을것이므로 무한루프를 돌게 될 것이다.

이런 경우는 문제가 되므로 임시방편으로 f가 상당히 커졌을 경우 탐색을 중지시킴으로써 해결할 수 있다.

하지만, 논리적으로 경로가 존재할 가능성이 있다는 문제가 있다.

이러한 문제를 어떻게 보완할 수 있을까?

<br>

### 노드의 고립

천천히 생각해보자. 출발지와 목적지가 이어질 수 없다는것은 뭘 의미할까?

**반드시 둘 중 하나는 고립되어있다**는 것을 의미한다.
[물론 두개의 서로다른 개방형 맵에 각각 존재한다는 이상한 상황을 제외한다면 말이다.]

- 출발지와 목적지가 이어져있다면 A*알고리듬으로 반드시 최단경로가 찾아진다.
- 개방형 맵에서 출발지와 목적지가 이어져있지 않다면, 둘 중 하나는 **반드시**고립된 상태이다.
- A*알고리듬은 **고립되어있다면 언젠가는 반드시 끝이 난다.**

위와 같은 특성을 이용한다면 해결법이 슬슬 떠오를것이다.

<br>

### 쌍방향 탐색

특성을 알면, 해결법은 간단하다.

양쪽에서 서로를 향해 탐색을 진행하면 되는것이다.
출발지에서 목적지를 향하는 탐색,
목적지에서 출발지를 향하는 탐색,

탐색이 완료된다면 경로가 존재할 것이고
만약 도착을 하지 않았는데 열린 노드 리스트가 비는 탐색이 발생한다면
`두 노드간의 경로는 존재하지 않는다.`

<br>

### 쌍방 절충 탐색

개방형 맵에서 확실하게 탐색을 종료할 수 있도록 설계를 완료했다. 다만, 여기서 살짝 개선할 여지가 있다.

굳이 하지는 않아도 괜찮지만 알아서 나쁠것은 없으니 알아두도록 하자.

<hr>

쌍방탐색은 도달 경로가 없을때에는 효율적인 탐색 방법이지만 경로가 존재할 경우, 한번으로 충분한 탐색을 두번 하게된다는 단점이 존재한다.

그렇다면, 서로 탐색을 진행해가면서 상대가 탐색해온 이력이 있는 노드를 만나는 순간, 그곳과 이어버린다면?

경로 탐색이 완료되는것이다.

<br>