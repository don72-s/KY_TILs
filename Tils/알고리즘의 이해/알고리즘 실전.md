# 알고리듬 실전

알고리듬의 개념은 알았으니 대표적인 알고리듬을 몇가지 알아보도록 하자!

<br>
## 정렬 알고리듬

많은 경우에 데이터를 쉽게 찾기 위해서라도 데이터가 정렬되어있기를 바라는 경우가 많다.

상황도 매우 다양하기에, 여러가지 정렬 알고리듬들이 고안되었는데 여러가지 정렬 알고리듬에 대하여 알아보도록 하자.

<br>
### 버블정렬
<br>
한번의 사이클(순회)에 정렬되지 않은 가장 큰 값 하나를 정렬하는 정렬이다.

사이클의 내부에서는 0번째부터 시작해서 다음 요소와 크기를 비교한 후, 더 큰 값을 가지는 값을 뒤로 보낸 뒤, 다음 인덱스에 대하여 해당 연산을 반복한다.

한번의 비교연산을 n번, 해당 n번의 비교연산을 n사이클,
따라서 O(n^2)의 시간 복잡도를 가지는 정렬이다.
<br>
### 선택정렬
<br>
한번의 사이클(순회)에 정렬되지 않은 가장 작은 값 하나를 정렬하는 정렬이다.

단순하게 처음(0번째)부터 끝까지 순회하며 가장 작은 숫자를 찾는다.

가장 작은 값을 가진 위치와 0번째 위치를 **바꾼다**

이렇게 0번째에는 가장 작은 값이 왔다.

다음 사이클에서는 1번째부터 끝까지 순회하며 가장 작은 숫자를 찾는다.

가장 작은 값을 가진 위치와 1번째 위치를 **바꾼다**

이렇게 1번째에는 두번째로 작은 값이 왔다.

해당 사이클을 n번 반복하며, 각 사이클에서는 가장 작은 값을 찾기 위해 n번을 순회하므로

O(n^2)의 시간 복잡도를 가지는 정렬이다.
<br>
### 삽입 정렬
<br>
1번째 요소와 2번째 요소의 정렬을 시작으로, 한 사이클마다 하나의 요소를 정리해가는 정렬이다.

손패의 카드를 가장 왼쪽부터 정렬한다고 생각하면 이해하기 쉬울 수 있다.

우선 첫번째와 두번째 요소의 정렬로 시작한다.

그럼 2번째 요소까지는 정렬이 완료되었다.

다음 3번째 요소의 정렬을 시작하는데, **정렬이 완료된 앞부분**에서 어느 사이로 **삽입**되어 들어갈지를 정한다.

조금 단적으로 표현해서 `버블정렬이 반대방향으로 돌아가는`알고리듬으로 표현할 수 있다.

따라서 O(n^2)의 시간 복잡도를 가지게 된다.
<br>
### 퀵정렬

<br>
분할 & 정복 기법의 일종으로, 자료가 주어진 배열을 두개의 부분배열로 나누어가며 정렬한다.

**pivot**이라고 불리는 값을 선정하고, 해당 pivot을 기준으로 pivot보다 작은 값들의 배열, pivot보다 큰 값들의 배열 두개의 부분 배열로 분할한다.

해당 과정에서 대략 **n번의 비교**연산이 일어난다.

**이상적**으로 배열이 분할되는 경우에는 반절씩 나눠질 것이다.

계속해서 반절씩 나누어진다고 가정했을 때, 사이클은 **logn**번 진행될 것이다. (이진트리의 높이와 같은 수치)

따라서 최선의 경우에는 **O(nlogn)** 의 시간 복잡도를 가진다.

다만, 최악의 경우 모든 pivot선정에 대해서 양끝값이 계속해서 선정되는 경우가 있다.

해당 경우에는 사이클의 횟수( 트리의 높이 )가 **n**번이 될 것이다.

즉, 최악의 경우에는 **O(n^2)** 의 시간 복잡도를 가지게 된다.
<br>
### 병합(합병) 정렬
<br>
퀵 정렬과 같은 원리이지만, 부분배열을 반드시 절반의 크기로만 나누는 정렬이다.

위의 퀵 정렬은 **나눌 때에 정렬을 시행**했고, **합할때**에는 합하는것 외에 다른 연산은 하지 않았다.

해당 방식의 단점은, 부분배열을 트리로 표현하면 트리의 구조가 안정적이지 않게 퍼져나가기 때문에 시간복잡도가 안정적이지 않다는 점이었다.

거꾸로 말하면, 트리의 높이를 안정적으로 구상할 수 있다면 사이클의 횟수를 logn으로 확정시킬 수 있다는 이야기다.

이런점을 이용한 것이 병합정렬이다.

정렬은 나중에 합하는 과정에 맡기고 우선 배열을 **균등**하게 나눈다 즉, 퀵 정렬의 pivot의 개념을 없애고 우선 나누는데에 집중한다.

그럼 부분배열은 반드시 **반절**씩 나눠져가고 높이는 logn인 이진트리 구조가 될 것이고, 리프노드는 **단 하나**의 데이터만 가진 상태일 것이다.

이제 다시 합하면서 정렬할 시간이다.

1개씩 나누어진 데이터 2개를 정렬하려면 두번의 비교가 필요하다. 1개로 나누어진 데이터는 n개이므로 n번의 비교연산이 필요하다.

다음층부터의 정렬에서는 약간 다른 양상을 보인다.
정렬된 두개의 부분배열의 가장 앞부분만을 기준으로 비교한다.

예를들어 다음과 같은 부분배열이 있다고 치자
`4,9   |   3,7`

두 배열을 합칠 때, 가장 앞인 3과 4만을 비교하여 더 작은 수를 가장 앞에 배치하며 합병하면 된다.

3의 뒤에 있는 7과 4의 뒤에있는 9는 이미 정렬된 부분배열이므로 가장 앞의 숫자보다는 반드시 크기 때문이다.

따라서 정렬된 부분배열 두개를 합칠때에는, 가장 앞의 요소들만 비교한 뒤에 작은 요소를 앞에 두는 방식으로 돌아가므로
해당 층에서의 비교연산횟수는 최대 n을 넘지 않는다.

위와같은 원리로 logn번의 사이클마다 각 n번의 비교 연산이 필요하므로

해당 정렬은 O(nlogn)의 시간 복잡도를 가진다.

<br>
### 힙 정렬
<br>
이진트리를 이용하여 정렬된 트리 구조를 이용한 정렬이며
최대, 최소 힙으로 나뉜다. 여기서는 최대힙을 기준으로 설명하기로 한다.

데이터가 선형적으로 정렬되는 구조는 아니며, 단지 부모 노드는 반드시 자식 노드보다 **크거나 같다**라는 조건을 만족하는 이진트리를 유지해주는 데이터 구조이다.

대표적으로 정렬이라기보다는 **우선순위 큐**를 구성하는 알고리듬으로 알려져있다.

상술했듯, 선형적인 정렬이 아니므로 가장 작은수부터 가장 큰 수까지 순차적으로 출력한다는건 사실상 불가능한 수준이다.

`이진트리`로 구현되어있으므로, `배열을 이용한`인덱스 접근과 좋은 시너지를 가진다.
`(현재 인덱스 + 1) / 2 = 부모 인덱스 + 1`의 관계를 가지기 때문이다.

즉, 선형적 자료구조인 배열로 논리적인 이진트리 구조를 구현할 수 있다는 의미이다.

잡설이 길었는데, 본격적으로 정렬을 해보자.

힙을 구성하는데는 데이터를 한번에 넣는것이 아닌, 하나씩 넣는 구조로 이루어진다.

배열의 가장 마지막 인덱스의 위치에 값을 넣게되며, 다음과 같은 로직을 수행한다.

```
값이 들어옴.

배열의 가장 마지막 인덱스에 값 추가(본인)
내 인덱스 = 배열 크기

while( 인덱스 != 0 or 부모의 크기가 나보다 작음){
    부모와 나의 위치 교체!
    
    내 인덱스 /= 2
}
```

배열상으로 완벽한 선형 정렬이 이루어지지는 않겠지만, 한가지는 반드시 보장하게 된다.

`배열의 0번째 요소는 항상 가장 큰 값이다.`

여기까지는 가장 큰 수를 위한 자료구조가 된다.
하지만 분명 해당 자료구조는 **우선순위 큐**의 기반 구조라고 이야기했었다.
큐 라는 자료구조는 삽입뿐만 아니라 자료의 삭제도 일어나야 한다. 그것도 그냥 제거가 아닌, 가장 큰 값이 먼저 제거되는 자료구조가 **우선순위 큐**이다.

그럼 이번에는 배열의 특징을 염두해가며 root의 값을 제거해보자.

우선 root의 값을 반환했다고 치고, 배열의 가장 마지막에 있는 데이터를 root에 덮어씌우고, 가장 마지막 위치를 **제거**한다. dequeue를 했으므로, 데이터의 전체 크기가 줄어야 정상이기 때문이다.

그럼 현재 root의 위치에는 아주 작은값이 들어가 있을것이다.

원래자리... 찾아가야겠지...?

원래 자리를 찾아가는 방법은 추가했을때의 반대로 시행하면 된다.

```
최대값이 dequeue된 후 일어날 일.

배열의 가장 마지막 요소를 0번째 인덱스로 옮긴 뒤 배열의 크기를 1 줄임.

현재인덱스 = 0

while(무한루프){

    if(자식이 하나도 없을 경우)
        여기가 내자리
        break;

    큰 자식 노드 인덱스 = [ (현재인덱스 + 1) * 2, (현재인덱스 + 1) * 2 + 1 ]
    
    if(나 >= 큰 자식 노드 인덱스의 )
        여기가 내자리
        break;
    else
        큰 자식 노드의 위치와 교체
        이어서 무한루프 반복
    
}
```

다음과 같은 동작으로 인해 가장 큰/작은 값을 항상 O(1)의 속도로 접근할 수 있도록 도와주는 구조이다.

이러한 구조의 특징으로 정렬을 원한다면 
`모든 값을 힙에 넣었다가 힙이 빌 때 까지 root의 값을 빼온다면`자연스럽게 정렬이 이루어진다.

삽입은 이진트리이므로 한번 삽입에는 logn의 시간이 걸리고
n개의 자료를 넣는데 n번의 사이클,
n개의 자료를 꺼내는데 n의 복잡도가 걸리므로

O(nlogn + n)의 시간 복잡도를 가지게 되며 즉
**O(nlogn)** 의 시간 복잡도를 가진다.

<br>
## 정렬들의 특징
<br>

정렬들은 시간복잡도와 공간복잡도만으로 사용성을 평가할 수 없다. 상황에 따라 작동원리를 이해하고 있어야 한다.

예를들면 다음과 같다.

- 버블정렬 : 연결리스트에서 사용할 수 있는 정렬 알고리듬
- 삽입정렬 : 16개 이하의 데이터에서는 매우 높은 효율
- 퀵정렬 : 최악인경우 n^2이지만, 데이터 할당을 불편해하는 c#의 특성상 많은 경우에 병합/힙 정렬보다 효율이 좋음
- 병합정렬 : 퀵정렬과 힙정렬은 불안정 정렬임에 비해 **안정 정렬**이다 이전에 정렬했던 기준을 섞지 않고 새로운 정렬 기준을 적용할 수 있다.

즉, 정렬의 원리와 상황을 이해하고 있는 것이 중요하다고 볼 수 있다.

<br>

## 배열에서의 탐색 알고리듬

지금까지 여러가지 알고리듬을 통해 정렬을 해온 이유는 뭘까? 보기 좋기 위해서?
물론 그런 이유도 있겠지만, 원하는 데이터를 찾기 쉽게 하기 위한 목적이 가장 클 것이다.

그렇다면 이제 데이터를 찾는 알고리듬들에 대하여 알아보자.

### 선형 탐색
<br>
가장 단순한 선형탐색에 대해 알아보자.

문자 그대로 선형으로 탐색해 나가는 알고리듬이다.
찾는 대상을 목표로 가장 첫번째 데이터부터 마지막까지 하나하나 비교해가는 방식이다.

따라서 단순히 비교시간은 O(n)이 걸리는 가장 확실한 방법이면서 가장 느린 탐색 방법이다.

유일한 장점은 탐색 대상이 정렬되어있지 않아도 탐색이 가능하다는 점이다.
<br>

### 이진 탐색
<br>
데이터가 많아질 수록 선형탐색은 매우 오래걸릴 수 있다.

만일 데이터가 데이터간 대소관계에 의해 정렬될 수 있다면 우리는 이진탐색을 고려할 수 있다.

이진탐색의 순서는 다음과 같다.

1. 데이터를 오름차순 또는 내림차순으로 정렬한다.
2. 정렬된 데이터의 중앙지점을 고른다.
3. 목표 데이터와 중앙지점의 데이터를 비교한다.
3.1 목표 데이터가 중앙지점의 데이터와 같다면, 현재 인덱스를 반환한다.
3.2 목표 데이터가 중앙지점의 데이터와 다르다면, 목표 데이터가 있지 않은 범위 반절을 버린다.
4. 반으로 줄어든 탐색범위를 대상으로 2번부터 반복한다.

직관적으로도 느낄 수 있듯, 탐색 범위가 한번의 사이클로도 절반으로 줄어듦을 확인할 수 있다.

따라서 정렬만 되어있다면 탐색의 시간 복잡도는 O(logn)이 됨을 알 수 있다.
<br>

## 그래프에서의 탐색 알고리듬

배열은 모든 자료가 선형적으로 이어져 있기 때문에 선형탐색이나 이진 탐색이 가능했다.

하지만 그래프는 여러곳으로 갈라져있는 자료구조이기 때문에, 탐색시 갈림길을 만났을 때에 어떤 방식으로 갈림길에 대한 탐색을 해야하는지 정해야 할 필요가 있다.

그래프에 대한 탐색 알고리듬은 해당 상황에 대한 처리 정책에 따라 크게 두가지 탐색 알고리듬으로 나뉜다.

<br>

### 깊이 우선 탐색 (DFS)
<br>

그래프에 대한 탐색을 하는 경우에 갈림길을 조우했을 시, 기준에 따라 하나의 갈림길을 먼저 정하고 해당 갈림길을 끝까지 탐색한 뒤에 가장 최근에 마주친 갈림길까지 돌아가 남은 갈림길에 대해 끝까지 탐색하는 순서로 탐색이 이루어진다.

트리 구조를 생각한다면 갈림길 정책에 대하여 가장 좌측 갈림길이 우선순위를 가진다는 정책을 채택했다고 하자.

그렇다면 가장 처음으로 가장 깊이 탐색되는 노드는 가장 왼쪽에 있는 리프 노드일 것이다.

그 뒤에 가장 최근 갈림길로 돌아와서 같은 행위를 반복하므로 두번째로 방문하는 가장 깊은 노드는 왼쪽에서 두번째에 있는 리프 노드일 것이다.

이렇게 기준 정책을 두고 갈림길을 마주쳤을 때, 하나의 갈림길을 먼저 끝까지 탐색하는 형태를 **깊이 우선 탐색**이라고 한다.
<br>

### 너비 우선 탐색 (BFS)
<br>
너비우선 탐색도 그래프에 있어서 탐색 정책의 차이일 뿐, 근본적으로는 크게 다르지 않다.

깊이우선탐색과의 차이는, 갈림길을 발견했을 때 해당 갈랫길들을 잠깐씩만 둘러본 뒤, 다음 갈랫길들을 처리한다는 차이가 있다.

트리로 비교한다면 깊이우선탐색은 최대한 빠르게 리프노드에 도달하는것을 목표로 하는 탐색이라면
너비우선 탐색은 트리의 한 계층을 내려갈 때 해당 계층의 탐색을 완벽하게 마친 뒤에 다음 계층으로 내려가는 넓게 훑는듯한 느낌의 탐색이다.
<br>

### 단절 노드와 추가데이터
<br>
그래프의 노드는 단절된 노드가 존재할 수도 있다.
따라서 탐색시에 해당 노드까지 도달할 수 있는지에 대한 정보를 저장할 수 있는 추가 메모리가 필요할 것이다.

일반적으로 노드갯수와 같은 크기의 bool배열을 만들게 되며, 방문한 순간에 true로 바꾸게 된다.

또한 해당 노드를 최초로 발견한 노드가 어느 노드인지 즉, 어느 노드의 갈림길에서부터 찾아온것인지 알기 위해서 노드 갯수와 같은 크기의 <노드 타입> 배열이 필요하게 될 것이다.
<br>

### 두 방식의 장단점
<br>

얼핏 보기에는 너비우선 탐색은 최단경로를 보장하기 때문에 너비우선 탐색이 더욱 우월해 보일 수 있다.

하지만 각각 장단점이 있는데 다음과 같다.

**깊이 우선 탐색**

- 탐색에 필요한 메모리가 적은 편이다.
- 트리에서 사용할 경우, 해당 노드까지의 경로가 반드시 하나이기 때문에 트리에서의 dfs는 최단경로를 보장한다.


**너비 우선 탐색**

- 하나의 계층에 대한 모든 노드 정보를 저장한 메모리 공간이 필요하다.
- 반드시 최단경로를 보장한다.

<br>

## 길찾기 알고리듬

그래프에서 특정 노드에 접근할 수 있는지, 없는지의 여부는 깊이/너비 탐색으로 확인할 수 있었다.

그리고 너비우선탐색에 의해 도달한 노드는 최단거리를 보장한다고도 했었다.

하지만, 이는 모든 간선의 가중치(비용)가 1인 경우를 상정한 경우이다.

만일, 간선들이 각자 다른 가중치를 가진다면 특정 노드까지의 최단거리(최소비용)를 어떻게 찾을 수 있을까?

### 다익스트라 알고리듬
<br>
다익스트라 길찾기 알고리듬은 다음과 같은 논리에 기반하여 작동한다.

1. 출발지를 제외한 모든 노드는 첫 시작 시 INFINITY의 비용을 가진다.
2. 출발지 노드는 시작 시 0의 비용을 가진다.
3. 다음으로 탐색할 노드를 선정하는데, 다음와 같은 기준으로 선정한다.
3-1. 현재 INFINITY가 아닌 노드들 중에, 검증하지 않은 노드들을 추려낸다.
3-2. 추려낸 노드들 중에, 방문 비용이 **가장 작은** 노드를 다음 탐색 노드로 선정한다. (같은 비용의 노드들이 존재한다면 선정 순서는 상관 없다.)
4. 선정된 노드를 거쳐서 도달할 수 있는 주변 노드들을 확인한다.
5. 주변 노드들의 기존 도달 비용과, 선정된 노드를 거쳐서 도달할 경우의 비용을 비교해본 뒤, 비용이 더 작은 경로를 최단경로로 갱신한다.
6. 선정된 노드를 검증한 노드로 체크한 뒤, 3번 과정으로 되돌아간다.
7. 더이상 검증할 노드가 없다면 탐색을 종료한다.
<br>
#### 알고리듬의 원리
<br>
다익스트라 알고리듬이 최단경로를 반드시 보장하는 이유는 다음과 같다.

- 접근이 가능한 노드들 중에, **총 비용**이 **가장 작은** 노드부터 검증 노드의 대상이 된다.

예를 들어 다음과 같은 경우를 보자.

1번 노드는 2번 노드와 3번 노드와 연결되며 각 비용은 5, 5이다

2번 노드는 4번 노드와 10의 비용으로 연결된다.
3번 노드는 4번 노드와 2의 비용으로 연결된다.

2번 노드와 3번 노드까지의 비용은 5로써 같다.
이 때, 2번 노드를 먼저 선정한다고 하면, 4번 노드까지의 **잠정 비용**은 15가 될 것이다.

그럼 이제 남은 노드는 3, 4번 노드인데, **3번 노드의 비용은 5**, **4번 노드의 비용은 15**가 되므로 3번 노드를 우선적으로 확인한다.

이렇게 검증한다면, 4번 비용까지의 **잠정 비용**은 7의 비용으로 갱신된다.

이렇게 검증하지 않은 노드는 해당 노드까지의 도달 경로가 **최소 비용**이 되기 전까지는 절대 검증을 시도하지 않는다.

즉, 시작 노드에서 도달할 수 있는 노드들 중에 비용이 **가장 작은 경로**로써 확정지을 수 있는 노드를 선정하여 최소비용으로 확정짓고, 해당 노드를 거쳐 지나가는 다음 노드들을 **검증 가능 대상**에 넣는것이 가능한 것이다.

`다만, 이는 가중치에 [음수] 가 없기 때문에 적용 가능한 알고리듬인 것이다.`

음수가 노드에 있다면 이미 최단이라고 확정시킨 노드에 도달하는 더 적은 경로가 발생할 수 있다.

다른 이야기지만, 음수인 간선이 있다면, 비용이 무한히 작아지는 음수 사이클이 발생할 가능성도 있다.

<br>