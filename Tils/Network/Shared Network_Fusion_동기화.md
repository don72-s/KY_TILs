# Shared (P2P) Network 동기화

네트워크 게임을 구성하는데에는 플레이어간의 데이터를 일관성있게 유지해야 한다는 것을 알았다.

어떤 방식으로 데이터를 동기화시킬 수 있는지에 대해 알아보도록 한다.

<br>

## 데이터의 동기화

기본적으로 프로그램은 저장된 변수를 기반으로 돌아간다.
따라서 변수를 동기화시키는것이 네트워크 프로그래밍의 첫 단계라고 할 수 있다.

<br>

### 동기화 어트리뷰트

fusion에서 동기화를 위해서는 NetworkBehaviour를 상속해야 한다고 했다.

여기에 더해 변수를 동기화 시키기 위해서는 특수한 어트리뷰트가 필요하다.

```cs
using Fusion;

public class Data : NetworkBehaviour{
    [Networked] public int hp {get; set;}
}
```

다음과 같이 `Networked`라는 어트리뷰트가 필요하며, 해당 동기화 변수는 반드시**프로퍼티**형태여야 한다.

또한, 해당 어트리뷰트가 붙은 값의 변경은 반드시 `소유권/권한`을 가진 클라이언트만이 수정할 수 있다.

마지막으로 networked 어트리뷰트를 통한 동기화는 **값 형식**데이터만 동기화가 가능하다. 즉, 일반필드와 구조체 형식만 networked로 동기화할 수 있다.
<br>

### 변경사항의 콜백

프로퍼티에서 자주 사용되는 방식인 **값이 변경된 뒤에 콜백 호출**방식을 Fusion에서도 사용할 수 있다.

OnChangedRender 어트리뷰트를 사용하는 방식인데, 사용 방법은 다음과 같다.

```cs
public class Data : NetworkBehaviour{
    [Networked, OnChangedRender(nameof(ChangedHp))]
    public int CurHp {  get; set; }

    [field: SerializeField]
    public int MaxHp {  get; private set; }

    public void ChangedHp() { 
        //콜백
    }
}
```

다만, 해당 콜백은 변수의 변화에 대한 콜백이므로, 소유권을 가진 클라이언트뿐만 아니라 영향을 받는 모든 클라이언트에서 콜백 함수를 호출하게 된다.

따라서, 모든 클라이언트가 해당 변수값의 변경에 대한 콜백 행위를 실행할 필요가 있을 때 유용하게 사용할 수 있다.

<br>

## RPC

네트워크에서 공유 데이터의 변경은 소유자만이 변경할 수 있어야 한다.

하나의 공유변수를 한명이 담당하여 순차적으로 수정을 일으키면 오류가 날 가능성이 현저히 줄어들기 때문이다.

따라서 특정 변수를 모두가 수정할 수 있는 구조가 아닌, 담당자만이 해당 변수를 관리하는 구조가 동반되어야 한다.

또한, 네트워크 환경에 따라서 환경 딜레이가 걸려서 동일한 타이밍에 특정 함수가 호출되지 않을 수 있다.

이를 위해 **특정 타이밍에 동시에 호출**되어야 하는 함수인 경우에도 특수한 처리가 필요할 것이다.

이러한 구조를 설계할 수 있도록 도와주는 기법이 RPC (Remote Procedure Call)이다.

<br>

### 약속된 물리 환경

기존의 Raycast를 생각해보자, Physics.Raycast를 이용해서 ray를 사용했었을 것이다.

하지만, 네트워크에서 통일된 물리 환경을 이용하기 위해서는 하나의 조건이 필요하다.

Fusion측에서 제공한 물리 환경을 사용하기 위해서 다음과 같은 코드가 필요하다.

`Runner.GetPhysicsScene()`

이를 통해 기본의 Raycast등을 사용할 수 있다.

<br>

### 실행 요청과 실행 권한

내가 총을 쏴서 상대편이 총을 맞았다고 치자, 그렇다고 해서 내가 상대 플레이어의 체력을 깎을 수 없다. 이는 보안적으로 매우 취약한 구조가 되기 때문이다.

따라서 나는 상대를 맞췄다는것을 알리는것만 가능하고, 실제로 이를 확인하고 함수를 실행시켜서 체력 수치를 조정하는것은 상대편 클라이언트에서 실행해야 하는 부분이다.

이러한 요청/실행 제한을 걸 수 있는 어트리뷰트가 `RPC`이다.

```cs
    [Rpc(RpcSources.All, RpcTargets.StateAuthority)]
    public void DamagedRpc(int _amount) {

        model.CurHp -= _amount;

    }
```

해당 어트리뷰트를 선언하면, 해당 함수는 Rpc함수로 취급되며 소괄호 안의 속성으로 제약을 설정할 수 있다.

첫번째 속성은 **누가 해당 함수 실행을 요청할 수 있는지**를 의미한다. 

위에서의 RpcSources.All은 모든 클라이언트가 해당 함수 실행을 요청할 수 있음을 의미한다.

<br>

두번째 속성은 **누가 해당 함수를 실행할 수 있는지**를 의미한다.

함수 실행 요청이 일어났을 때, RpcTargets.All이었다면 모든 클라이언트에서 해당 인스턴스에 대한 대상 함수들을 각자 실행하게 될 것이다.

위에서의 RpcTargets.StateAuthority 속성은, **해당 컴포넌트가 포함된 오브젝트의 소유권을 가진 클라이언트**에서만 해당 함수를 실제로 실행시키게됨을 의미한다.

마지막으로 Rpc어트리뷰트가 붙은 함수는
`함수명이 반드시 Rpc로 끝나야 한다.`

<br>

