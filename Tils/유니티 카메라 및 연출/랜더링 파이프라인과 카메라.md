# 렌더링 파이프라인과 카메라

내부에서는 3D 물체를 다룰지 몰라도 결국 화면상으로 출력하게 된다면 2D로 바뀌게 된다. 즉, 최종 출력을 위해 그려야 할 부분을 추려내야 한다는 것이다.

해당 과정을 렌더링 파이프라인이라고 한다.

<br>

## 기본적인 렌더링 파이프라인

대표적인 그래픽 시스템인 directX와 OpenGl등의 프로그램에서는 다음과 같은 순서를 따른다.

1 - 입력조립 : 주어진 정점들을 기준으로 로컬 공간 도형을 구성한다.

<hr>

2 - 정점 셰이더 : 조립된 요소들을 변환 행렬을 이용하여 해당하는 월드좌표의 위치로 이동시킨다.

- 모델 변환 : 로컬 좌표계에 있는 물체를 월드공간에 위치하도록 이동시키는 변환이다.

- 뷰 변환 : 카메라 위치를 기준으로 잡고 다른 물체들의 상대 위치를 지정하는 변환이다

- 투영 변환 : 원근감에 맞도록 각 요소의 정점들을 투영 평면 상에 대응시켜서 표현한다.

투영 결과는 -1~1사이를 가지는 2 * 2 * 2의 공간 안에 표현되며, 해당 결과물을 **절두체**라고 한다.

해당 과정에서 **클리핑**과 **후면 컬링** 또한 일어나게 된다.

<hr>

3 - 레스터라이저 : 사용자마다 모니터의 해상도 설정이 다를 것이다. 이에 맞춰서 그려야 할 도형들을 픽셀들로 대응시키는 단계이다.

스캔 변환을 이용하여 도형의 내부인지 판단하고, 경계면인 경우 칠할지 말지를 결정한다.

<hr>

4 - 픽셀 셰이더 : 각 출력 픽셀에 어느 색을 칠해줄지 결정하는 단계. 해당 방법은 여러가지 방식들이 존재한다.

- 텍스쳐 - 질감 표현과 텍스쳐 매핑으로 미리 색 속성을 지정해놓는다. 
- 노말 맵 - 표면의 법선을 표현하는 방식이다. 즉, 각지게 표현되는 표면을 더 둥글게 굴곡을 주기 위해 사용된다.

>단, 실제로 둥글어지는것이 아닌, 빛반사에만 영향을 끼치며, 이에 대한 착시로 인해 부드럽거나 굴곡이 있어보이게 만든다.
[rgb로 법선벡터를 표현하기 때문에 텍스쳐가 푸르게 보인다.]

- 빛 - 법선벡터를 이용하여 입사각, 반사각등을 구한 뒤, 밝기 정도의 비율을 정하게 된다.

<hr>

5 - 출력 병합 : 각 픽셀은 출력결과가 겹칠 수 있다. 그러한 경우에 최종적으로 출력될 색상을 결정하는 방법이다.

- 깊이 버퍼 - 물체를 그릴 때 먼 물체부터 그린 뒤에 가까운 물체를 나중에 그려서 색을 덮어쓰게 만든다.

- 알파 블랜딩 - 투명한 물체를 표현해야할 때가 필요할 것이다. 하지만 모니터는 투명색상이 없으며 이를 표현할 때에는 뒤에있는 색을 섞음으로써 표현하게 된다.

- 스텐실 테스트 - 오브젝트들이 겹쳐지거나 보여질 부분들 등을 마스크 용도로 사용하여 테스트할 수 있다.

<br>

## 렌더링 파이프라인의 순서

위의 과정을 천천히 알아보도록 하자.

<br>

### 뷰 포인트 지정 (카메라 지정)

우선 출력할 화면 즉, 카메라가 찍는 위치, 시야각, 깊이 등을 설정한다.

이 과정은 카메라를 옮기는것처럼 보이지만 연산상의 이득을 위해 내부에서는 사실 카메라 이외의 모든 요소가 움직이는 구조를 취한다고 한다.

<br>

### 컬링

3D 물체를 현실에서 볼때도 뒷면같은 사각지대는 보이지 않는다. 즉, 2D인 화면에 표현하는데에 그리지 않아도 되는 부분들이 절반 이상 존재한다.

이 부분의 폴리곤들을 제거함으로써 상당한 연산적 이득을 취할 수 있으므로 컬링 알고리즘의 효율성은 렌더링 과정의 효율로 이어진다.

<br>

### 조명처리

각 폴리곤들의 밝기 정도를 직광, 간접광, 반사광, 표면의 성질등을 고려하여 지정한다.

<br>

### 클리핑

뷰 볼륨 즉, 그려야 하는 카메라 영역 밖의 요소들을 모두 제거하는 과정이다.

<br>

### 투영

투영 방식에 따라 **원근투영** 또는 **직교투영**등의 방식을 선택한다.

<br>

### 뷰 포트 변환

-1~1 범위로 만든 절두체를 이용해 목표 출력 해상도로 확장시킨다.

<br>

## 셰이더 프로그래밍

셰이더는 출력 방식 그 자체를 변경하는 방식이라고 했었다.
이 이야기는 기존의 기능을 완전하게 대체할 수 있어야 한다는 의미이기도 하다.

이러한 이유로 셰이더의 교체는 정점/픽셀 셰이더 단계에서 교체가 많이 되며, 픽셀 셰이더는 그래픽 카드에서 이루어지므로 교체할 수 없다.

<br>

## 카메라

랜더링 과정에서는 결국 카메라 위치가 매우 중요하다는 점을 알게 되었다.

- culling mask
카메라를 설정할때에는 컬링시킬 오브젝트 레이어들을 지정할 수 있다.

- viewport Rect, depth
  여러개의 카메라일 경우, 출력한 결과와 출력할 순서를 설정할 수 있다.

- camera stacking
  하나의 카메라로 표현하기 어려운 구조를 여러개의 카메라 장면으로 쌓아가면서 표현할 수도 있는 기법이다
ex) 마인크래프트의 손 / fps의 총과 스코프 줌인,아웃 등등..



<br>

### 카메라와 프레임 드랍

캐릭터의 움직임에 따라서 카메라가 장면을 비추는경우가 보통의 게임 구조일 것이다.

그런데 update는 정해진 순서에 따른 동작이 아니다보니 플레이어가 나중에 호출된 경우 카메라가 잘못된 곳을 비출 수 있다.

<br>


### LateUpdate()

update사이클중에서 적어도 update의 작업이 모두 끝난 뒤에 호출을 시작하는 lateupdate라는 함수가 있다.

이곳에 카메라 제어 동작을 넣어주면 모든 캐릭터의 이동 연산이 끝난 후, 카메라의 촬영 영역에 의도된 캐릭터의 촬영을 보장할 수 있다.

<br>