# 레이어 마스크

레이어와 레이이마스크는 충돌 제어에서 한번 사용했었다.
이는 그룹화를 시켜서 랜더링을 결정하는데에도 사용할 수 있다.

<br>

## 렌더링 레이어 선별

상술했듯, 렌더링될 레이어를 지정할 수 있다.

방법은 카메라 컴포넌트에서 CullingMask속성에서 렌더링될 레이어들을 체크해주면 된다.

<br>


## 레이어 마스크의 구조

레이어 마스크의 내부 동작 구조는 물리연산에서 한번 정리했었다.

그때의 내용을 다시 한번 가져와봤으니 다시 리마인드 해보도록 하자.

<hr>

layerMask는 자료형은 정수이지만 조금 특별한 방식으로 layer를 구분, 저장한다.

int는 32비트로 표현되는 정수형 자료구조이며, 각 비트는 x번째 레이어를 의미한다.

즉, ......0000 0100 라는 십진수 4는 3번째 레이어를 의미한다.
또한 ...0000 0110 라는 십진수 6은 2번째와 3번째 레이어를 의미한다.

따라서 레이어의 번호는 1, 2, 3과 같이 정수의 진행이 아닌
각 비트의 활성화 여부로 해당 레이어의 체크를 확인한다.

<hr>

위의 레이어 마스크의 구조를 인지하여 int값을 넣어주면 활성화된 레이어 그룹에 있는 충돌체를 마주쳤을 때에만 true를 반환한다.

#### 단, 0을 전달한 경우에는 예외로써 모든 종류의 충돌체를 검출 대상에 넣는다.

+) 최신 유니티 버전에서는 LayerMask 변수를 인스펙터에서 설정할 수 있다.

<br>

### 비트연산자

유니티에서 레이어마스크 설정을 직관적으로 제공해주지만, 코드상으로 직접 지정해야 할 때가 있을 수 있다.

그럴 때 필요한게 비트연산자이다.
이는 특정 값의 비트값에 직접 관여하는 연산이며
컴퓨터에서 가장 빠른 연산이다.

<hr>

- & : and연산, 두개의 값을 비교하여 각 자릿수의 비트가 둘 다 1인 경우 해당 자릿수 비트를 1로 설정하여 반환한다.
- | : or연산, 두개의 값을 비교하여 각 자릿수의 비트가 하나라도 1인 경우 해당 자릿수 비트를 1로 설정하여 반환한다.
- ~ : not연산, 모든 비트를 반전시킨다.
- <<, >> : 시프트연산, 모든 비트를 화살표 방향으로 뒤에있는 정수만큼 밀어버린다. 빈칸은 모두 0으로 채워진다.
<br>

### enum과 layermask

레이어마스크를 비트연산을 이용하여 논리적으로 잘 다룰수 있게 되었다.

이러한 자료형을 enum을 통해 직접 정의할 수도 있다.

enum을 선언할 때, 각 값을 비트별로 정의해두고

[System.Flags] 어트리뷰트를 선언하면 된다.

<br>