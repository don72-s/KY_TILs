# 2D 애니메이션

3D에서는 관절을 움직이는등의 동작을 애니메이션이라고 칭했었다.

하지만 관절이 없이 스프라이트만 존재하는 2D에서의 애니메이션은 무엇을 의미하고 어떻게 동작할까?

<br>

## 키프레임 애니메이션

키프레임 애니메이션은 한 단어로 요약하자면 **플립북**이다.

키 프레임을 지정하고, 해당 키 프레임에 출력할 스프라이트들을 등록하여 시간이 지남에 따라 출력 스프라이트를 전환하는 애니메이션 방식이다.

<br>

### 스프라이트 준비하기

플립북 방식으로 애니메이션을 준비하려면 당연히 여러개의 스프라이트들이 필요할 것이다.

보통은 제공되는 스프라이트 아틀라스로부터 슬라이스해서 사용하게 된다.

기존 방식대로 스프라이트 에디터를 통해서 슬라이스를 하던, 별도의 스프라이트들을 여러개 준비하던, 연속될 동작의 스프라이트들을 준비하면 된다.

<br>

### 애니메이션 만들기

애니메이션 생성은 기존의 애니메이션 생성/적용 방법과 같다.

대상이 될 오브젝트에 animator 컴포넌트를 추가한 뒤, animation controller 파일을 만들고 연결한 뒤 해당 오브젝트를 선택하여 animation을 생성해준다.

여기에서 3D의 경우 애니메이션 파일에서 키프레임에 따른 변동사항을 지정했었지만, 2D에서는 키프레임마다 아까 준비했던 스프라이트들을 지정해주면 스프라이트 애니메이션 생성이 완료된다.

<br>

## 키 프레임 애니메이션의 관리

이전까지의 애니메이션간 전환에서는 **트랜지선**과 **파라미터**를 통하여 제어했었다.

하지만 블랜드 트리, 애니메이션 마스크를 사용할 수 없는 2D애니메이션에서는 애니메이션 상태와 트랜지션이 많아질수록 엄청나게 복잡해질것이다.

만일 2D 키프레임 애니메이션을 사용할 것이고 후에 배울 상태패턴을 이용하여 스크립트 내부에서 해당 오브젝트의 상태를 가지고 있을 것이며, 이에 대응하는 애니메이션을 재생시키는 구조를 채택한다면 **트랜지션을 사용하지 않는 방법**을 고려해볼 수 있다.

<hr>

2D 키프레임 애니메이션은 트랜지션을 통해 상태를 전이할 때 딱히 트랜지션의 기능을 이용하지 않는다.

따라서 **특정 상태일 경우, 대응되는 애니메이션을 출력**하는 방식으로도 구성할 수 있다.

위의 방식을 위해서 코드 내부에서 특정 애니메이션을 플레이시키는 코드는 다음과 같다.

`animator.Play([애니메이션 이름]);`

<hr>

다만, string으로 전달해준다면 가비지의 축적, 탐색 비용때문에 은근히 신경쓰일만한 자원과 연산 낭비가 발생하게 된다.

따라서 가능하다면 다음과 같은 방식을 사용하는것이 더욱 권장된다.

`animator.Play((int)[정수로 해싱된 애니메이션 해시값]);`
<hr>
그렇다면 해당 해시값을 가져오는 방법이 있어야 하겠다. 해당 코드는 다음과 같다.

`int hashVal = Animator.StringToHash([해싱할 애니메이션 이름]);`

##### 위의 코드는 언제나 같은 값을 가지므로 Static 변수에 넣어놓고 공유하여 사용하는 방법이 매우 효율적이므로 강하게 권장된다.
<hr>
<br>
따라서 enum등의 딕셔너리등으로 저장시켜놓은 뒤 재활용해서 사용하게 된다면 **메모리 최적화도 챙기고 탐색 속도도 줄일 수 있는** 1석 2조의 효과를 낼 수 있겠다.

<hr>
<br>

위와 같은 방식을 사용하면 적어도 animator창이 거미줄처럼 복잡해지는 현상은 막을 수 있다.

또한 코드는 원래 상태마다 파라미터를 바꾸었으므로 오히려 코드 복잡성 또한 줄어들 가능성도 존재한다.

따라서 키 프레임 애니메이션을 사용한다면, 상황과 조건에 따라 고려해볼만한 방식이다.

<br>

## 스파인 애니메이션

키프레임 애니메이션 이외의 2D지만 각각 관절들을 지정하여 애니메이션화 시키는 방법도 있다.

이 방식을 스파인 애니메이션이라고 하며 3D애니메이션과 비슷하게 관절 기반으로 동작하기 때문에 위의 키프레임 애니메이션과는 다르게 에니메이터의 메카님을 사용하는것이 더욱 효율적이다.

<br>

## 스프라이트 아틀라스로 묶기

지금까지 여러개의 스프라이트들을 아틀라스에서 자르고 사용하고 했었다.

그렇다면 반대로 하나의 아틀라스로 만들어서 전달하거나 다루는 방법은 없을까?

해당 방법에는 스프라이트 아틀라스를 유니티에서 새로 만들 수 있다.

에셋 메뉴에서 Create -> 2D -> Sprite Atlas 를 만들고 Include In Build 항목을 체크한다면 빌드 이후에 해당 아틀라스를 가지고 그래픽 처리를 하기 때문에 그래픽 카드의 부담을 줄여줄 수 있다.

아래 항목에 Objects for Packing에 사용하는 스프라이트들을 지정해놓는다면(폴더단위로도 가능) 빌드 이후에는 해당 아틀라스를 사용하게 된다.

#### 다만, 아틀라스를 만들었다고 기존 스프라이트를 지우면 안된다.

<br>