# 2D 환경 개발

게임이나 프로그램이라고 반드시 3D환경의 게임일 필요는 없다. 따라서 2D환경으로 구성된 게임을 만들수도 있다.

그럴때에는 기존처럼 3D환경에서 만들어야 하느냐?

그건 또 아니기 때문에 2D환경에서 개발할 수 있도록 개선된 2D전용 컴포넌트들을 제공한다.

2D개발 환경은 기존 3D환경과 무엇이 다른지 알아보도록 하자.

<br>

## 환경 구성의 차이

사실 구성 환경은 크게 차이가 없다. 굳이 찾자면 2D 패키지가 깔려있다는 정도?

2D시점으로 시작되지만, 3D환경으로 바꿔서 개발할 수도 있다.

초기설정에 의한 가장 큰 차이점은 다음과 같다

- skybox, light가 처음에 자동으로 생성되지 않는다.
- 임포트된 이미지는 자동적으로 sprite형식으로 지정된다.
- 게임을 시작할때 자동으로 2D시점으로 시작한다.

<br>

## 오브젝트

2D 프로젝트로 생성하고 2D패키지가 깔려있으니, 구성요소들은 2D로 생성해야 할 필요가 있겠다.

계층뷰에서 Create를 누른다면 2D object라는 항목이 있는것을 볼 수 있다.

이러한 2D 오브젝트는 3D와 비슷하지만 약간 다른 컴포넌트들을 사용한다.

<br>

### rigidbody 2D

2D에서의 물리 연산은 rigidbody2D라는 별도의 컴포넌트를 이용한다. 

기본 rigidbody와 크게 다른점은 없지만, 기본적으로는 z축과 관련된 요소들을 제거하여 오브젝트간의 연산량이 최적화되어있는 경우이다.

즉, 두개의 요소가 3D환경에서는 z축이 벌어져있어 떨어져야 하는 상황에서 rigidbody2D 컴포넌트로 연산된다면 떨어지지 않는다.

<hr>

#### 컴포넌트간의 독립성

그렇다면 rigidbody와 rigidbody2D는 둘다 물리연산을 한다면 상호간의 영향을 끼치느냐 하면 그것은 또 아니다.

rigidbody와 rigidbody2D컴포넌트는 서로 다른 종류의 컴포넌트로 취급되어 둘 사이에는 어떠한 연산적 영향을 주지 않는다. 즉, `상호간의 물리적 연산이나 간섭이 일어나지 않는다.`

<br>
## 카메라의 물체 깊이 판별

보통의 2D물체는 z좌표를 기반으로 뒤에 있는 물체를 먼저 그리게 된다.

하지만, 쿼터뷰 시점과 같은 게임은 y좌표를 기반으로 위에 있는 물체가 먼저 그려져서 가려지게 하고 싶은 경우가 있다.
ex)스타듀벨리, 포켓몬 등등

이러한 경우에는 카메라의 설정을 바꿔줌으로써 원하는 효과를 낼 수 있다.

- Project Settings -> Graphics 항목의 Camera Setting을 custom으로 바꾸어준 뒤, (0, 1, 0)등으로 렌더링 순서를 조정해주면 된다.

<hr>

만일 위치에 따라서 가려지는 방식이 달라지지 않고, 언제나 그려지는 순서의 일관성이 있는 물체들의 종류라면, Layer를 이용할 수 있다.

2D물체의 컴포넌트의 Sprite Renderer의 속성의 Additional Settings에서 Sorting Layer를 설정할 수 있다.

하단의 Order in Layer는 같은 레이어일 경우에 해당 스프라이트간 우선순위를 정하는 수치이다.

<br>

## 스프라이트 설정

스프라이트를 받아온다면 기본 단위크기를 설정할 필요가 있다.

스프라이트의 설정에 들어가본다면 Pixel Per Unit 파라미터가 있을 것이다.

해당 파라미터의 의미는 씬뷰의 1크기(Scale)일때 몇 픽셀을 들어가야하느냐를 의미한다.

`다만, 해당 PPU는 2의 제곱수로 설정하는것이 성능적인 최적화에 도움이 된다.`

<hr>

#### 피벗 설정

크기가 다른 두개의 스프라이트가 있다고 하자, 기본적으로 스프라이트들의 피벗은 중앙을 기준으로 되어있다.

크기가 둘쭉날쭉인 여러 스프라이트들은 같은 바닥에 서있게 되더라도 서로 다른 높이정보(y position)를 가지게 될 수 있다.

이는 판정을 하거나 위치이동을 시킬 때 각 타입마다 기준점이 다르게 된다는 의미이므로 그렇게 바람직한 경우는 아니다.

따라서 경우에 따라서 pivot을 조정해 줄 필요가 있다.

특히 캐릭터들의 기준 위치는 발밑으로 조정해두는 경우가 일반적이다.

이후, 해당 피벗 설정을 이용한다는것을 명시해 주어야 하므로, 실제로 생성한 오브젝트의 sprite renderer설정에서 **Sprite Sort Point**를 Pivot으로 바꾸어 주어야 한다.

<br>

### 스프라이트 아틀라스

스프라이트를 하나의 파일로 주는 경우도 있겠지만, 대부분의 경우 여러개의 스프라이트들이 하나의 파일에 모여있는 **스프라이트 아틀라스**형태의 스프라이트로 넘겨주는 경우가 많다.

그래픽카드의 연산 특징에 의해, 100개의 파일들중 그릴 파일을 찾아서 그리는것보다, 100개의 그림들이 모여있는 하나의 파일에서 **특정 부분만 그리는**경우를 더욱 선호하기 때문이다.

따라서 이런 경우에는 에디터에서 이미지들을 잘라서 사용해야 할 것이다.

<br>

이러한 스프라이트 아틀라스의 내부 그림들을 여러개의 그림으로 분리해서 사용하고 싶다면, 스프라이트 설정에서 **Sprite Mode**를 multiple로 설정한 뒤, **Sprite Editor**를 들어가면 되겠다.

에디터에 들어선 다음에는 설정에 따라 스프라이트들을 슬라이싱해준 뒤 저장하면, 하나의 큰 스프라이트를 여러개의 스프라이트로 취급하여 사용할 수 있게된다.


<br>

### 스프라이트와 9-슬라이스

스프라이트를 사용하는데에 있어서 영역이 내부 영역, 외부 영역 두개의 영역으로 분리되어있는 스프라이트가 있을 수 있다.

대표적인 예로써 대화창에 사용되는 스프라이트를 생각해보자.

**각 귀퉁이 4조각.
상, 하, 좌, 우 모서리 4개.
내부영역 1개**

이렇게 9개의 영역으로 나눌 수 있다.

만일 해당 이미지를 그대로 쓴다면?
해상도에 따라 해당 스프라이트를 잡아 늘렸을 때 해상도가 떨어지거나 모서리의 두깨 비율이 망가질수도 있다.

이러한 현상을 효율적으로 해결하기 위해 사용되는 기법을
`9-slice`라고 한다.

즉, 아무리 늘리고 줄이더라도 가운데 영역을 제외한 boarder의 부분의 최소 크기와 비율 유지를 보장하며 확장해준다.

따라서 대화창 등을 구현할 때, 작은 이미지로도 여러가지 크기의 창을 통일성 있게 표현할 때 효율적인 기법이다.

<hr>

pivot과 마찬가지로, 해당 방식으로 사용하고 싶다면, sprite renderer 컴포넌트로 가서 **Draw Mode**를 **Sliced**로 바꾼 뒤 적용하면 된다.

<br>

## 물리연산의 적용

앞서 잠깐 언급했듯이, 3D 물리연산과 2D 물리연산은 완전히 별도로 동작한다고 했다.

따라서 기존에 사용했던 방식대로 OnCollision 메세지들은 2D물리연산에서는 동작하지 않는다.

따라서 2D연산에서는 `OnCollision2D, OnTrigger2D`시리즈를 사용해야 한다.

<br>

### Raycast2D

분명 2D환경에서도 레이캐스트를 진행해야할 것이다.

계속해서 말하지만 기존에 사용하던 방식들은 모두 3D인 경우이기 때문에 2D정보를 이용해서 레이캐스트를 해야한다.

따라서 다음과 같이 레이캐스트를 사용하면 된다.
`Physics2D.Raycast([시작점], [방향]);`

다만, 3D와는 다르게 out으로 결과가 나오지 않고, 바로 반환값으로 나오며, 충돌체가 없을 경우 null을 반환하게 된다.
때문에 이러한 차이점만 유의하여 사용하면 되겠다.

<br>

## 2D와 이펙터

2D는 대부분 플랫포머 기반의 기능을 구현해야할때가 많다.
이러한 기능들을 2D에서는 컴포넌트 기반으로 많이 제공하는데
그 중 한가지가 이펙터이다.

#### Platform Effector
특정 각도에서 접근하는 충돌을 무시하도록 마스킹할 수 있다.
예를들어 발판 아래에서 머리를 부딛히는것이 아닌 통과하도록 할 수 있다.
<br>

#### Point Effector
해당 콜라이더 영역의 중심을 기준으로 끌어당기거나 밀어내는 힘을 가할 수 있다.
<br>

#### Surface Effector
해당 콜라이더 영역의 표면에 충돌중인경우, 속도를 추가하는 등의 작업을 줄 수 있다.
<br>

#### Buoyancy Effector
물에 뜨는 효과를 줄 수 있는 부력의 영향을 받도록 할 수 있다.
<br>

#### Area Effector
해당 영역의 내부에서는 설정된 방향으로의 힘을 지속적으로 받도록 설정할 수 있다.
<br>

- 이외의 여러가지 종류의 이펙터들이 있다.

<br>

### 2D와 시네머신

2D모드에서 사용할 수 있는 시네머신 카메라는 한종류밖에 존재하지 않는다.

따라서 그냥 캐릭터를 쫒아다니는 카메라 용도로 사용할 수 있다.

<hr>

2D 게임에서는 촬영의 끝 영역이 있을 수 있다.

최하단 바닥의 아래는 비추지 않는다던지, 한쪽 끝에서는 카메라가 더 가지 않고 멈춘다던지의 설정이 필요할 수 있다.

이럴때, 시네머신의 버추얼 카메라의 extention을 통해 **Cinemachine Confiner 2D**를 추가해 준 뒤,
촬영이 가능한 영역을 Polygon 충돌체등으로 영역을 정의하고 해당 충돌체 컴포넌트를 연결해주면 된다.

<br>