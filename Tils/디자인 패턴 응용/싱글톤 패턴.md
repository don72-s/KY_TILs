# 싱글톤 패턴

프로그램을 설계하다보면 언제나 어디서나 접근할 수 있고 하나의 객체만 존재했으면 하는 데이터 구조를 원하는 경우가 분명 있을 것이다.

싱글톤 패턴은 이러한 요구를 충족시키는 패턴이다.

매우 편하고 강력한 패턴이지만 단점들이 존재하는데 이를 반드시 유의하고 사용해야 하는 패턴이다.

<br>

## 싱글톤 기본 구조

싱글톤 패턴은 디자인 패턴이라 정해진 구현법은 없지만, 대체로 다음과 같은 방식으로 구현된다.

```cs
class Single {

    static Single instance = null;

    public static Single GetInstance() {

        if (instance == null) { 
            instance = new Single();
        }

        return instance;

    }

}
```


유니티같은 라이프사이클이 존재하는 곳에서는 다음과 같이 작성할수도 있다.

```cs
class Single {

    static Single instance = null;

    Awake(){
        if(instance == null){
            instance = this;
        }else{
            Destroy(gameObject);
        }
    }

    public static Single GetInstance() {

        return instance;

    }

}
```

<br>

### 유일성

싱글톤은 유일성을 보장해야 한다고 했다.
따라서 위의 코드를 보면 하나의 인스턴스만 존재하도록 보장하는 코드들을 볼 수 있다.

`if( instance == null ) instance = new Single();`

처음 사용시에 없다면 그때서야 새로운 객체를 만들어 반환하고 이미 사용했던 적이 있다면 null이 아닐 것이므로 생성되었던 인스턴스를 반환한다.

이러한 초기화 방식을 **게으른 초기화**방식이라고 부르는데, 클래스의 크기에 따라서 초기화하는데에 시간이 소요되는 경우, 초기화 타이밍을 잘 조절하거나 로딩중에 미리 인스턴스를 만들어놓는것을 고려해야 할 수 있다.

유니티에서는 **Awake**를 이용하여 이를 통제한다.

```cs
Awake(){
        if(instance == null){
            instance = this;
        }else{
            Destroy(gameObject);
        }
    }
```

해당 인스턴스가 이미 존재한다면 현재의 오브젝트는 제거한다.

instance는 static으로 선언되어있기 때문에 유일성을 확인할 수 있다.

<br>

### 전역성

GetInstance함수는 public, static으로 되어있다. 이 이야기는 클래스명을 통하여 어디서나 호출할 수 있음을 의미한다.

따라서 해당 인스턴스는 어느곳에서나 전역적으로 받아올 수 있다는 이야기다.

따라서 자연스럽게 전역성을 가지게 된다.

<br>
## 주의점

그냥 설명만 들었는데도 사용하기 편리해보인다.
 하지만 싱글톤을 사용할때에는 신중해야 한다.
<br>

### 씬의 오브젝트 참조를 지양

싱글톤 인스턴스는 씬을 옮겨다니는 인스턴스이다. 이 이야기는 특정 씬의 객체를 참조하는 경우, 씬을 옮겨가는 경우 이전 씬의 객체는 제거되기 때문에 참조 미스가 생긴다.

이러한 방식을 이용하고 싶다면, 해당 씬의 객체가 start시에 싱글톤에 본인 객체를 전달하는 방식을 사용해야 한다.

<br>

### 전역적인 접근을 허용하기 때문에 책임이 막중함.

싱글톤은 여러곳에서 접근할 수 있는 관리자 역할을 하는 경우가 많으며, 따라서 너무 많은 기능을 가지고 있는 경우가 많다. 즉, 너무 많은 책임을 가지는 경우가 많다.

<br>

### 단위 테스트가 어렵다.

디버그할 때에는 테스트 영역을 특정 구간으로 한정하는 경우가 많다. 하지만, 싱글톤 객체를 사용하는 구간이라면 단위 테스트가 조금 힘들어질 수도 있다.

싱글톤 객체는 여러곳에 의해 영향을 받기 때문이다.

<br>

### 두가지 문제를 동시에 해결하려 한다.

싱글톤은 **전역성, 단일성**의 특징을 가진다. 문제점은 **반드시** 두가지의 특징을 **모두** 가진다는 점이다.

즉, 전역성만을 가지게 할 수 없고, 또한 단일성만을 가지게 할 수 없다.

따라서 현재 상황이 반드시 싱글톤을 사용해야 하는 상황인지 한번 더 고려해볼 필요가 있다.


<br>

## 유니티 씬의 전환

유니티에서는 장면을 전환하는데 **씬**이라는 개념을 사용한다.

다만 싱글톤 이용에서의 문제가 되는 점은, 씬을 넘어갈 때, 기존 씬에 있던 인스턴스, 오브젝트등의 데이터는 가지고 넘어가지 않는다는 것이다.

그렇다면 싱글톤 객체를 씬마다 하나씩 만들어놓아야 할까?

<br>

### DontDestroyOnLoad

씬과 씬 사이를 넘나들며 공유해야 하는 데이터들이 있을 수 있다.

이를 위해서 유니티에서는 특별한 씬인 **DontDestroyOnLoad**라는 씬이 존재한다.

이름에서 유추할 수 있듯, 씬이 로드될 때 파괴되지 않는 오브젝트들이 모여있는 곳이다.

즉, 싱글톤 객체들을 해당 씬에 소속되게 만들면 씬을 옮길때에 삭제되지 않는다.

다음과같은 코드 한줄로 해당 객체를 제거되지 않게 할 수 있다.
`DontDestroyOnLoad( 게임오브젝트 );`

<br>

