# 상태 패턴

대부분의 경우, 해야하는 일이 조금이라도 많아진다면 해당 객체가 어떤 행동을 하고 있는지 파악하거나 제어하기가 어려워지기도 하고, 행동마다 코드를 수정하기가 힘들어진다.

이러한 상황을 조금 더 직관적이고 코드 편집을 수월하게 할 수 있도록 도와줄 수 있는 패턴이 상태 패턴이다.

<br>

## 행동의 분리

요지는 행동들이 많아지고, 해당 행동들이 추가되거나 수정이 이루어지는 경우이다.

해당 행동들은 객체의 특정 상태일때에만 이루어지므로 상태에 따라서 하는 행동들을 캡슐화시켜서 분리시키는 것이 상태패턴의 기초적인 개념이다.

<br>

### 행동과 상태의 전환

그동안 상태가 바뀌어서 행동을 전환할때에는 조건을 빠듯하게 체크해야했다.

현재 어떤상태이고, 어떤 상태로 전환하면 안되고, 어떤 상태들로 전환할수있고 또 동일한 입력에 대해서 현재 어느 상태로 전환해야하고...

벌써 머리가 아파온다. 여깃에서는 발상의 전환을 할 필요가 있다.

애초에 하나의 update에서 모든 입력을 통합적으로 받는것 자체가 복잡도가 늘어나는 원인이다.

즉, **현재 상태별로 입력을 받도록** 로직을 구현하면 복합적인 조건식 검사가 불필요해진다.

<br>

### 전이의 제한

상술한것처럼 상태들을 분리해주고 각 상태들에서 해야 할 행동들을 독립적으로 작성해준다면, 다른 상태로의 전이를 구성하기도 편하다.

만일, 각 상태들이 독립적이지 않았다고 가정해보자.

정지, 달리기, 점프 3가지 상태가 있는 상황에서 **슬라이딩**상태를 하나 추가했다고 하면 통합적인 입력을 가지고 처리를 해야 할 것이다.

아래(↓)키를 눌렀을 때 슬라이딩 상태로 전환해야한다고 하면, `점프 상태인 경우 아래키가 눌렸을 경우 전환하지 않음`이라는 예외사항 조건문을 추가해야 할 것이다.

<hr>

만일 상태들이 독립적으로 존재한다고 생각한다면, 해당 상황을 거꾸로 설계할 수 있다.

기본상태, 달리기상태의 독립적인 입력처리에서 아래키가 눌렸을 때 슬라이딩 상태로 바꿔주도록 작성할 수 있는 것이다.

현재상태 체크, 복합적인 조건문 작성같은 머리아프고 햇갈리는 상황을 피할 수 있다.

<hr>

조금 직관적으로 정리하자면, 상태들을 독립시키지 않았을 경우에는 새로운 상태가 추가될 때 `모든 전이를 가능하게 한 뒤, 불가능한 전환에 대응하는 전이를 제거`하는 방식이었다.

하지만 상태들을 독립시키게 된다면 새로운 상태가 추가될 때 `새로운 상태로 전환이 가능한 전이를 추가`하는 방식이 된다.

따라서 상태들이 늘어날 수록 기존 방식이라면 **조건을 확인하고 지워야하는 전이**들이 기하급수적으로 늘어날 것이다.

하지만 반대로 **새로운 상태로 전이할 수 있는 전이를 추가**하는것은 독립적으로 작성이 가능하고, 직관적으로 추가가 가능하기 때문에 논리적인 실수가 발생할 가능성이 낮아진다.

<br>

### 독립성과 수정 용이성

상태에 따라서 행동들을 분리해서 구현해 놓았으므로 의도에 따른 코드 수정이 용이해진다.

상태와 대응 행동의 정의가 명확해지므로 행동을 수정할 때에 대상 행동을 찾는 혼란을 줄여줄 수 있고 무엇보다 버그가 발생했을 경우 어느 행동과 어느 상태에서 버그가 발생했는지 쉽게 확인할 수 있게 된다.

<br>

### any state

계속해서 어디서 많이 본 듯한 구조가 나온다.
사실 상태패턴은 여지껏 봐온 유니티 애니메이터 그래프와 같은 방식이기 때문이다.

그런데 애니메이터에는 하나의 상태가 더 있었다.
바로 any state였다.

해당 상태도 논리적으로 구현할 수 있다.

any state를 포함한 상태 분기 코드는 다음과 같다.

```cs
void Update(){

    swtich(state){
    
        case State.Idle:
            Idle();
            break;
        case State.Dead:
            Dead();
            break;    

    }
    
    AnyState();

}

public void AnyState(){

    if(hp <= 0)
        state = State.Dead;

}
```

즉, 현재 어느상태이든 상관 없이 마지막에 anystate에 의한 전이가 일어나도록 구성할 수 있다.

<br>

## 주의점

상태패턴은 현재 상태에 대응하는 행동을 하는 일종의 분기문이라고 볼 수 있다.

따라서 switch문과 같은 맥락을 가지므로 지켜져야하는 점이 있다.

`객체는 한번에 하나의 상태만을 가져야 한다.`

즉, 논리적으로는 **점프하면서 공격**하는 등의 행동이 가능할 듯 하지만, **점프**와 **공격**상태를 동시에 가질수는 없다는 이야기이다.

따라서 복합 상태를 원한다면, 해당 복합 상태를 **별도로**작성해야 한다.

<br>

## 함수형 상태구분과 간섭

상태를 분리하여 독립적으로 사용한다는것은 알겠다.
하지만 위와같이 함수를 기반으로 상태를 구분하게 된다면 문제가 발생할 수 있는 여지가 하나 있다.

결국 같은 클래스 내부에 정의되어있는 함수들이기 때문에 실수로라도 서로의 동작에 간섭하는것이 가능하기 때문이다.

따라서 상호간의 간섭을 없애기 위해서 각 update로 분기된 함수들을 private 상태로 선언된 innerClass의 인스턴스로 교체해주는 방법을 사용할 수 있겠다.

```cs
public class BaseState{

    public virtual void Enter(){}
    public virtual void Update(){}
    public virtual void Exit(){}

}

//==== 기존 상태클래스의 내부

private class Idle : BaseState{

    //외부 간섭이 불가능한 변수# 상태 패턴

대부분의 경우, 해야하는 일이 조금이라도 많아진다면 해당 객체가 어떤 행동을 하고 있는지 파악하거나 제어하기가 어려워지기도 하고, 행동마다 코드를 수정하기가 힘들어진다.

이러한 상황을 조금 더 직관적이고 코드 편집을 수월하게 할 수 있도록 도와줄 수 있는 패턴이 상태 패턴이다.

<br>

## 행동의 분리

요지는 행동들이 많아지고, 해당 행동들이 추가되거나 수정이 이루어지는 경우이다.

해당 행동들은 객체의 특정 상태일때에만 이루어지므로 상태에 따라서 하는 행동들을 캡슐화시켜서 분리시키는 것이 상태패턴의 기초적인 개념이다.

<br>

### 행동과 상태의 전환

그동안 상태가 바뀌어서 행동을 전환할때에는 조건을 빠듯하게 체크해야했다.

현재 어떤상태이고, 어떤 상태로 전환하면 안되고, 어떤 상태들로 전환할수있고 또 동일한 입력에 대해서 현재 어느 상태로 전환해야하고...

벌써 머리가 아파온다. 여깃에서는 발상의 전환을 할 필요가 있다.

애초에 하나의 update에서 모든 입력을 통합적으로 받는것 자체가 복잡도가 늘어나는 원인이다.

즉, **현재 상태별로 입력을 받도록** 로직을 구현하면 복합적인 조건식 검사가 불필요해진다.

<br>

### 전이의 제한

상술한것처럼 상태들을 분리해주고 각 상태들에서 해야 할 행동들을 독립적으로 작성해준다면, 다른 상태로의 전이를 구성하기도 편하다.

만일, 각 상태들이 독립적이지 않았다고 가정해보자.

정지, 달리기, 점프 3가지 상태가 있는 상황에서 **슬라이딩**상태를 하나 추가했다고 하면 통합적인 입력을 가지고 처리를 해야 할 것이다.

아래(↓)키를 눌렀을 때 슬라이딩 상태로 전환해야한다고 하면, `점프 상태인 경우 아래키가 눌렸을 경우 전환하지 않음`이라는 예외사항 조건문을 추가해야 할 것이다.

<hr>

만일 상태들이 독립적으로 존재한다고 생각한다면, 해당 상황을 거꾸로 설계할 수 있다.

기본상태, 달리기상태의 독립적인 입력처리에서 아래키가 눌렸을 때 슬라이딩 상태로 바꿔주도록 작성할 수 있는 것이다.

현재상태 체크, 복합적인 조건문 작성같은 머리아프고 햇갈리는 상황을 피할 수 있다.

<hr>

조금 직관적으로 정리하자면, 상태들을 독립시키지 않았을 경우에는 새로운 상태가 추가될 때 `모든 전이를 가능하게 한 뒤, 불가능한 전환에 대응하는 전이를 제거`하는 방식이었다.

하지만 상태들을 독립시키게 된다면 새로운 상태가 추가될 때 `새로운 상태로 전환이 가능한 전이를 추가`하는 방식이 된다.

따라서 상태들이 늘어날 수록 기존 방식이라면 **조건을 확인하고 지워야하는 전이**들이 기하급수적으로 늘어날 것이다.

하지만 반대로 **새로운 상태로 전이할 수 있는 전이를 추가**하는것은 독립적으로 작성이 가능하고, 직관적으로 추가가 가능하기 때문에 논리적인 실수가 발생할 가능성이 낮아진다.

<br>

### 독립성과 수정 용이성

상태에 따라서 행동들을 분리해서 구현해 놓았으므로 의도에 따른 코드 수정이 용이해진다.

상태와 대응 행동의 정의가 명확해지므로 행동을 수정할 때에 대상 행동을 찾는 혼란을 줄여줄 수 있고 무엇보다 버그가 발생했을 경우 어느 행동과 어느 상태에서 버그가 발생했는지 쉽게 확인할 수 있게 된다.

<br>

### any state

계속해서 어디서 많이 본 듯한 구조가 나온다.
사실 상태패턴은 여지껏 봐온 유니티 애니메이터 그래프와 같은 방식이기 때문이다.

그런데 애니메이터에는 하나의 상태가 더 있었다.
바로 any state였다.

해당 상태도 논리적으로 구현할 수 있다.

any state를 포함한 상태 분기 코드는 다음과 같다.

```cs
void Update(){

    swtich(state){
    
        case State.Idle:
            Idle();
            break;
        case State.Dead:
            Dead();
            break;    

    }
    
    AnyState();

}

public void AnyState(){

    if(hp <= 0)
        state = State.Dead;

}
```

즉, 현재 어느상태이든 상관 없이 마지막에 anystate에 의한 전이가 일어나도록 구성할 수 있다.

<br>

## 주의점

상태패턴은 현재 상태에 대응하는 행동을 하는 일종의 분기문이라고 볼 수 있다.

따라서 switch문과 같은 맥락을 가지므로 지켜져야하는 점이 있다.

`객체는 한번에 하나의 상태만을 가져야 한다.`

즉, 논리적으로는 **점프하면서 공격**하는 등의 행동이 가능할 듯 하지만, **점프**와 **공격**상태를 동시에 가질수는 없다는 이야기이다.

따라서 복합 상태를 원한다면, 해당 복합 상태를 **별도로**작성해야 한다.

<br>

## 함수형 상태구분과 간섭

상태를 분리하여 독립적으로 사용한다는것은 알겠다.
하지만 위와같이 함수를 기반으로 상태를 구분하게 된다면 문제가 발생할 수 있는 여지가 하나 있다.

결국 같은 클래스 내부에 정의되어있는 함수들이기 때문에 실수로라도 서로의 동작에 간섭하는것이 가능하기 때문이다.

따라서 상호간의 간섭을 없애기 위해서 각 update로 분기된 함수들을 private 상태로 선언된 innerClass의 인스턴스로 교체해주는 방법을 사용할 수 있다.

```cs
public class BaseState{

    public virtual void Enter(){}
    public virtual void Update(){}
    public virtual void Exit(){}

}

//==== 기존 상태클래스의 내부

private class Idle : BaseState{

    //외부 간섭이 불가능한 변수
    private float localValue;

    //함수동작 override

}
```

다음과 같이 행동함수를 inner Class로 변환해주고,
switch문을 대응하는 클래스의 update를 호출하는등의 행동을 하도록 해주면 되겠다.

<br>

### 인스펙터와의 응용

만일 각 inner 상태 클래스를 **serializable**로 선언하고 내부에서 사용하는 변수들에 **serializedField**어트리뷰트를 달아준 다음, 해당 innerClass를 유니티 인스펙터에서 접근할 수 있도록 해준다면 인스펙터에서 innerClass의 필드들을 지정해줄 수 있다.

예를들면 다음과 같다.

```cs

class outerClass{

    [serializField]
    Move moveState = new Move();

    [System.Serializable]
    private class Move: BaseState{
    
        [serializeField]
        float moveSpeed;
    
        //함수동작 override
    
    }
}
```

위와같이 작성하면 인스펙에서 moveSpeed 값을 조정할 수 있다.

따라서 디버그를 할 때 유용하게 활용할 수 있다.

<br>