# 스크립터블 오브젝트

csv와 json등의 형태로 데이터를 직렬화하여 다루게 되면
데이터의 수정과 관리가 편했다.

하지만, 형식대로 불러오고 저장하는 코드를 작성해야하는 번거로움이 있었다.

이러한 번거로움을 없애고 데이터 수정을 용이하게 할 수 있는 개념이 스크립터블 오브젝트이다.

<br>

## 스크립터블 오브젝트

캐릭터의 능력치 파라미터, 무기 객체 파라미터등, 갖가지 파라미터들이 코드 내부에 병합되어있다면, 해당 수치를 조절하기 위해 코드를 직접 수정해야 할 것이다.

만일 코드가 엄청 크고 복잡하다면 다시 빌드하는데에만 시간이 많이 들 것이다.

<hr>

스크립터블 오브젝트는 이러한 데이터 용도로 사용되는 객체들을 스크립터블 오브젝트라는 구조로 직렬화하여 파일로 관리할 수 있게 해준다.

이러한 방식으로 코드와 데이터를 분리할 수 있게 만들어주기 때문에 데이터끼리 모아서 다루기 쉬워지며, 같은 타입의 스크립터블 오브젝트끼리는 교환도 가능해진다.

즉, 코드 내부의 특정 수치들의 변경/유지보수를 매우 직관적이고 유연하게 할 수 있다.

<br>

### 스크립터블 오브젝트의 정의

스크립터블 오브젝트는 데이터라고 했다.
굳이 비교하자면 구조체나 클래스와 같은 개념이기 때문에 기본 틀이 필요하다.

또한 유니티 로직과는 분리된 데이터 구조가 되어야하므로 유니티에서 기본적으로 상속되어있는 MonoBehaivor가 아닌 **ScriptableObject**를 상속해야한다.

이후의 작성 내용은 기존 클래스와 완전히 동일하다.
필요한 필드와 함수를 작성하여 스크립터블 오브젝트 정의를 마치면 된다.

```cs
class SO : ScriptableObject{
    public int level;
    public string name;
    public void LevelUp(){
        level++;
    }
    //...기타 등등...
}
```

<br>

### 스크립터블 오브젝트의 생성

스크립터블 오브젝트는 클래스/구조체와 비슷한 개념이라고 했다.

그렇다면 new 역할에 해당하는 인스턴스의 생성은 어떻게 할 수 있을까?

스크립터블 오브젝트는 코드 로직과 별도로 관리되는 데이터라고 했었다. 따라서 코드가 아닌 외부에서 만들어주어야한다.

이를 위해 해당 클래스의 윗부분에 다음과 같은 어트리뷰트를 추가해 줄 필요가 있다.
```cs
[CreateAssetMenu(menuName = "디렉토리(이름)", fileName = "생성되었을 때 기본으로 설정될 파일명"]
class SO : ScriptableObject{
    //...생략...
}
```

해당 어트리뷰트를 작성하게 된다면, 프로젝트에서 우클릭 -> Create의 내부 메뉴에 menuName에 작성한 항목명이 생기게 되며, 이를 선택하면 fileName으로 지정한 이름의 스크립터블 오브젝트를 만들 수 있다.

<br>
### 내부 필드 수정

스크립터블 오브젝트를 무사히 만들었다면, 이제 더 설명할 필요도 없다.

해당 오브젝트를 클릭하게 된다면, 인스펙터 내에서 필드 데이터를 수정할 수 있다.
[직렬화가 가능하고 public등으로 인스펙터에 표시가 가능한 필드의 경우]

<br>

### 공유성과 경량화

스크립터블 오브젝트는 직관적이지만 클래스와 완전히 같은 특징을 가지고 있다.

우리는 인스턴스화에 해당하는 생성과정을 한번만 진행했다.

이 말은, 여러가지 오브젝트에서 해당 오브젝트를 **참조**하여 사용하게 된다는 것이다.

즉, 어떤 오브젝트에서 해당 스크립터블 오브젝트의 내부 속성을 **변경**하게 된다면, 해당 스크립터블 오브젝트의 내부 속성을 참조하는 모든 대상에게 영향을 끼치게 된다.

따라서 이러한 특징을 인지하고 수치가 변화하는 파라미터의 경우에는 초기화 과정에서 초기값을 복사해오는 방법이 의도한 동작을 구현할 수 있을 것이다.

<hr>

그렇다면 반 강제로 읽기 전용의 특성을 가지게된다고 볼 수 있는데 접근성과 사용성이 쉬운 특징을 이용하여 공유되는 같은 값들은 해당 스크립터블 오브젝트를 참조하도록 하여 경량화를 유도할 수 있다. 이를 경량화 패턴이라고 한다.

<hr>

따라서 주의할 점은, 의도하는경우가 아니라면 내부의 필드속성을 바꿀 수 없도록 프로퍼티를 사용해 읽기 전용으로 만드는것이 권장된다.

또한, 내부에 함수를 구현할 경우 같은 흐름으로 본인의 또는 다른 스크립터블 오브젝트의 속성을 함부로 수정하는 일은 없어야 한다.

그러므로 특정 로직을 수행할 경우, 매개변수로 받아서 내부 필드를 읽어와서 연산에 사용한 뒤, 결괏값을 반환하는 형식으로 작성하는것이 가장 이상적이다.

결론은 `정말 특별한 경우가 아닌 이상` 스크립터블 오브젝트의 속성은 코드 로직에서는 데이터 수정은 일어나면 안되는 일이라는 것이다.

#### 런타임중에도 함부로 수정 금지

런타임중에 수정한 파라미터들이 프로그램을 멈추면 초기값으로 돌아가는것에 익숙해져있다보니, 플레이 테스트중에 값을 이리저리 바꾸는 경우가 있을 수 있다.

`절대로 함부로 바꾸면 안된다.`
플레이모드를 멈춰도 예전값으로 돌아가지 않는다!

<br>