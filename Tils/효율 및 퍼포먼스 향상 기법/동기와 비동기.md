# 동기와 비동기

대표적인 비동기인 로딩씬을 생각해보자.

우리는 무언가 로딩될 때 로딩바 또는 빙글빙글 도는 아이콘등을 본적이 있을 것이다.

만약 100%동기식이라면 로딩이 이루어지는 동안 로딩씬은 완전히 멈춰있을것이다.

그럼 비동기 방식인 로딩씬은 어떻게 만들수 있을까?

<br>

## 동기와 비동기

비동기방식을 만들기 위해서는 동기와 비동기가 무엇인지 정확히 이해해야 할 필요가 있다.

**동기** : 모든 일은 순차적으로 진행되며, 이전 작업이 끝나기 전에는 **절대로**다음 작업을 진행하지 않음.

**비동기** : 작업들이 병렬적으로 진행되며, 이전 작업이 완료되지 않았더라도 다음 작업이 동시에 진행됨.

<br>

### 타임 쉐어링과 멀티스래딩

여러 작업들이 동시에 실행되는 비동기 방식에는 타임 쉐어링 방식과 멀티스래딩 두 종류가 있다.

여기서도 큰 차이점이 있으니 **반드시**알고 가야한다.

**타임 쉐어링** : 여러가지 일이 병렬적으로 진행된다. 단, 여러명의 작업자가 하나씩 일을 맡아서 하는것이 아니라, **한명의 작업자**가 모든 일들을 돌아가면서 작업하는 방식이다.

즉, 10개의 일이 있다면 1번작업 한 프레임, 2번작업 한 프레임, 3번작업 한 프레임.....10번작업 한 프레임, 다시 1번작업 한 프레임... 과 같은 방식으로 작동하는것이 타임 쉐어링 방식이다.

따라서 비동기 방식은 **병행성**은 가지지만 실제로 **병렬성을 가지지 않는다.**

<hr>

**멀티스래드** : **병행성**과 **병렬성**을 모두 갖추는 작업 방식이다. 여러개의 작업으로 나누어진다면 그만큼 같은 순간에 동시에 작업을 처리하게 된다.

<hr>

조금 더 직관적으로 설명하자면, 어느 순간에 시간을 멈춰보자.

타임 쉐어링 방식은 10개의 작업들 중 하나만 작업하는 상태일 것이다.

멀티스래딩 방식은 10개의 작업들 중 10개 모두 작업하는 상태일 것이다.

<br>

## 코루틴

우리는 유니티에서 코루틴이라는 개념을 접했다.

그런데 코루틴은 여러가지 일을 동시에 맡겨놓으면 맡긴 일들을 모두 병렬적으로 처리하는것처럼 보였다.

하지만, 코루틴은 **비동기**방식으로 작동하지만, 엄밀히 말하자면 **타임 쉐어링을 사용하여 병행성을 가지는 동기방식**으로 구현되어있다.

즉, `병행성을 가지는 동기방식`으로 구현된 로직이다.

<br>
### yield의 의미

yield의 의미가 이제 구조적으로 조금 이해가 될 것이다.

코루틴들은 update의 작업이 모두 끝난뒤에 실행된다.

그렇게 제어권을 넘겨받을 코루틴들이 어딘가에 쌓여 있으며, 하나씩 제어권을 넘겨받는다.

그리고 yield를 만날때까지만 작업을 한 뒤, 다음 코루틴에게 제어권을 넘기는 방식이다.

이런 작업이 매우 빨리 벌어지기 때문에 코루틴들이 동시에 돌아가는것처럼 보이는 것이다.

<br>

## 비동기와 멀티스래딩

그렇다면 왜 굳이 멀티스래딩을 놔두고 동기 방식을 사용했을까?

멀티스래딩은 매우 빠르긴 하겠지만, 주의할 점이 엄청나게 많다.

이는 멀티스래딩을 사용하는 운영체제에서조차 해결하지 못한 문제이다.

(놀랍게도 이 문제에 의해 멈추면 그냥 컴퓨터를 껐다 켜라고 한다...)

<hr>

건설 현장을 생각해보자.

5종류의 작업에서는 모두 망치가 필요하다.
하지만 망치는 1개밖에 없다.

혼자서 5개의 작업을 돌아가면서 한다고 가정해보자(비동기)
그렇다면 문제될것이 없다.

만약 5명의 작업자가 하나씩 맡아서 작업을 한다고 하면?
망치는 1개밖에 없다... 제대로 작업이 진행될리가 없다.

<hr>

이와 비슷한 일이 멀티스레드에서 신경써야 하는 가장 치명적인 단점이다.

하나의 변수를 여러 작업에서 공유한다고 가정하자.

첫번째 작업에서는 +10, 두번째 작업에서는 -5를 한다고 하면
이상적으로는 +10 -5가 이루어져야한다.

하지만 첫번째 작업이 끝나기 전에 두번째 작업이 동시에 시작해버린다면?

둘 다 0이었던 값을 가져오게 될 것이다.
그렇게 첫번째 작업이 종료될 때 10을 저장해놯는데
두번째 작업이 끝난 시점에는 그냥 -5로 덮어버릴것이다.

이러한 공유자원의 문제가 발생해버린다.

<br>

### 뮤텍스와 세마포어

그렇다면 어떻게 할까? 답은 단순하다.
첫번째 작업이 끝날때까지 두번째 작업을 시작하지 않으면 된다.

그렇다면 단순하게 생각하게 된다면 1번이 끝난뒤에 2번 작업을 한다.

그러므로 이미 공유자원에 누가 접근하고 있다면 해당 자원을 필요로 하는 다른 작업을 시작시키지 않으면 된다.

이러한 방식을 **뮤텍스( mutex )** 라고 한다.

또한, 자원의 공유가 아니라 특정 실행 영역에서 실행되는 스레드의 갯수를 제한하고 싶을 수도 있다.

하지만 뮤텍스는 반드시 하나의 스레드로만 제한한다.

이럴때 **세마포어( semapore )** 라는 기법을 사용하게 된다.

<hr>

설명의 흐름에서 눈치챘을 것이다.

즉, 두가지 기법은 상황마다 속도가 현저히 다르다.

공유 자원이 존재하는 작업들이라면 **코루틴이 효율이 더 좋을 것이다.** 하지만, 공유자원이 없다면? 당연히 **멀티스래딩이 효율이 좋을수밖에 없다.**

<br>

### 교착상태

멀티스래딩 환경에서 볼 수 있는 가장 끔찍하고 도달하면 안되는 상태이다.

특정 스레드가 a를 사용중에 있었다.
그런데 다른 스레드가 b를 사용하기 위해 접근했다.

같은 시간이 지난 후, 첫 스레드가 b를 이용할 일이 생겨서 두번째 스레드의 종료를 기다리게 되었다.

그런데 갑자기 두번째 스레드도 작업을 종료하기 위해서는 a를 사용해야하는 일이 생겼다.

이렇게 되면 두 스레드는 어느쪽도 먼저 종료되지 못하고 무한정 대기하는 상태가 되어버린다.

이런 상태를 교착상태라고 하며, 멀티스레딩에서 반드시 피해야하는 상태이다.

<br>

## 로딩씬의 구현

위에서 멀티스래딩의 주의점과 타임 쉐어링과의 차이점을 보았다.

그렇다면 로딩씬은 어떤 방식으로 구현하는것이 더 좋을까?

<hr>

먼저 로딩씬의 역할을 알아보자.

로딩씬은 보통 백그라운드에서 무엇인가 다운로드되는것을 기다리는동안 심심하지 않거나 명시적으로 프로그램이 멈추지 않았다는것을 인식시키게 하기 위해 사용된다.

따라서 서로 공유하는 자원은 없다.
정확히 말하자면, 다운로드 진행도를 보여주기 위해서 진행도를 **읽어오는**순간은 있을수 있지만, **덮어쓰는**작업을 하지는 않는다.

즉, 서로 잘못된 영향을 끼칠수 있는 공유변수를 사용하는 부분이 없으므로 충분히 멀티스레드를 **리스크 없이**사용할 수 있는 부분중 한 곳이 로딩씬과 로드 부분이다.

<br>

### 스레드의 사용

스레드도 코루틴과 같이 사용하기 위해서는 별도의 사용법을 사용해야 한다.

다만 주의할점은 스레드는 코루틴과 달리 유니티에서 직접적으로 다루지 않는 스레드를 사용하기 때문에 **반드시 명시적으로 종료해주거나 종료해주어야 한다.**

즉, 스레드를 종료시켜주지 않는다면, 유니티 에디터에서 일시정지를 시켜도 백그라운드에서 계속 돌고있게 될 것이다.

c#에서 가장 단순하게 스레드를 사용하는 방법 중 하나는 다음과 같다.

`Task.Run([스레드에서 돌릴 함수명]);`

<br>

## 씬의 로딩 방법

지금까지는 씬의 전환을 그렇게 적극적으로 사용하지는 않았었다.

하지만 앞으로는 자주 사용하게 될 것이기 때문에 로딩방법에 대하여 알고 있어야 한다.

<hr>

모든 씬 전환 관련 함수는 **UnityEngine.SceneManagement** 네임스페이스의  **SceneManager**클래스에 작성되어있다.

<br>

### LoadScene

`SceneManager.LoadScene([불러올 씬 이름]);`

씬을 불러오는 가장 기본적인 함수이다.
실행되는 순간부터 **동기**방식으로 다음 씬을 로딩해오며, 로딩이 끝나기 전까지는 로딩 연산 이외의 **모든 연산을 중지**한다.

즉, 이동하기 전의 씬에서는 로딩이 완료되기 전까지는 **정지**한 상태가 될 것이며, 로딩이 끝난 뒤에 해당 씬으로 이동할 것이다.

그렇게 큰 씬이 아닐경우에는 별 문제가 아닐수도 있지만, 로드하는에 오랜 시간이 걸린다면 사용자 입장에서는 프로그램이 멈춘것으로 착각하고 프로그램을 종료시킬 가능성이 있다.

<br>

### LoadSceneAsync

`SceneManager.LoadSceneAsync([불러올 씬 이름]);`

LoadSceneAsync는 함수명 그대로 비동기식으로 씬을 불러온다.

해당 함수가 호출되면, 비동기방식으로 해당 씬을 로드하게 되고, 현재 씬이 **정지하지 않는다.**

그렇게 각자 비동기식으로 돌아가다가 씬의 로드가 완료된 순간, 해당 씬으로 전환하게 된다.
<br>
#### LoadSceneAsync의 반환값

비동기로 씬을 전환하게 되면, 현재 씬 변환이 되어가는 상태, 현황등을 확인해야 할 필요가 있다.

이를 위해서 LoadSceneAsync함수는 **AsyncOperation** 타입의 자료형을 하나 반환해준다.

해당 반환값의 파라미터를 통해서 현재 로딩이 얼마나 진행되었는지, 로드가 완료된 후 바로 씬을 전환할것인지등의 설정을 할 수 있다.

<hr>

- **allowSceneActivation** : 로딩이 완료되었을 때 자동으로 씬을 전환할지의 여부.
- **isDone** : 로딩이 완료되었는지의 여부.
- **progress** : 현재 진행된 로딩 % [ 0 ~ 1 ]   **씬을 넘기지 않도록 설정되어있다면, 0.9 이상으로 넘어가지 않는다.** 
- 

<br>

### 일반적인 비동기 씬 로드 코드

```cs

public void ChangeScene(){

    StartCoroutine(Load(nextScene));

}

IEnumerator Load(string _sceneName){

    AsyncOperation op = SceneManager.LoadSceneAsync(_sceneName);
    
    op.allowSceneActivation = false;
    
    while(op.isDone == false){
    
        if(op.progress < 0.9f){
            
            //로딩중

        }else{
        
            //로딩 완료
            //씬 전환
            op.allowSceneActivation = true;
        
        }
        
        yield return null;

    }

}
```

현재 씬에서 비동기로 로딩할수 있는 최대 비율은 90퍼센트이다.

따라서 90퍼센트가 넘는 경우에는 씬을 넘겨야 하는데, 해당 10퍼센트의 시간이 오래걸릴수도 있다.

따라서 남은 10퍼센트를 위한 처리 코드가 추가로 필요할수 있다.

<br>

### 추가 처리 코드

```cs
//위의 while문 뒤에 작성될 코드들
Time.timeScale = 0; //씬 시간 흐름 정지

//나머지 10퍼센트의 로딩 작업 및 씬 초기 작업 수행

Time.timeScale = 1; //씬 시간 흐름 진

```

<br>


### LoadSceneMode

지금까지는 자연스럽게 씬을 로딩했다.

그럼 그때는 아예 씬을 새로운 씬으로 전환되었는데
유니티에서는 여러개의 씬을 하나의 장면에 덧대서 표현할 수 있다.

이럴때에는 씬을 불러올 때 두번째 매개변수로 LoadSceneMode.Additive로 설정해주면 된다.

다만, 이럴때에는 audiolistener등이 중복처리되지 않게, 중복되어서 로딩이 되지 않도록 반드시 하나의 씬만 유지되게 하는 등의 주의가 필요하다.

<br>