# 네비게이션 매시

환경을 구성하다보면 특정 지점까지의 경로를 탐색해야하는 경우가 생긴다.

이런 자동이동 같은 기능을 구현하기 위해서 어떤 방법을 쓸수 있을까?

<br>

## 3D에서의 길찾기

2D환경에서는 A*알고리즘을 직접 구현해야 한다. 이는 추후에 따로 배우기로 하고, 그렇다면 3D 환경에서는 어떻게 구현해야 하나?

다행인점은 유니티에서는 NavMesh라는 기능을 제공한다.

해당 기능을 이용하여 3D환경에서 이동할 수 있는 지역들을 미리 스캔하고, 해당 지점들을 이용하여 길찾기를 구현한다.

<br>

### NavMesh 생성

네비게이션 매시를 사용하기 위해서는 우선 window -> AI -> navigation 창을 열어야 한다.

또한 네비게이션 매시를 사용할 대상인 NavMeshAgent가 필요하므로 길찾기 행위를 할 객체에 NavMeshAgent컴포넌트를 부착해준다.

<br>

### navMap과 static

사실 실시간으로 경로를 탐색하는 연산은 매우 많은 연산량을 필요로 한다.

따라서 네비메시의 동작은 빛과 반사처럼 **미리 연산해 두는** bake 방식으로 돌아간다.

따라서 미리 계산할 경우에는 해당 물체는 **움직이지 않을 것이다**라는 설정이 필요하며 이러한 경우에 해당되는 구성요소들은 static type을 **navigation static**으로 바꾸어줄 필요가 있다.

<br>

### navigation의 설정

경로를 탐색해놓는 경우에, 여러가지 설정이 필요할 수 있다.

이 때에는 navigation창에서 속성들을 설정하여 map bake 기준을 조정할 수 있다.

- **agent radius** : agent가 지나갈 수 있는 반지름의 크기
- **agent height** : agent가 지나갈 수 있는 최소 높이
- **max slope** : agent가 올라갈 수 있는 최소 경사각
- **step height** : agent가 오를 수 있는 최소 단차
<br>
- **drop height** : agent가 뛰어내릴 수 있는 최대 높이
-  **jump distance** : agent가 뛰어넘을 수 있는 최대 거리

<hr>

#### 에이전트 타입별 설정

bake에 있는 옵션들은 범용적인 옵션이 된다.
만일 에이전트의 타입별로 움직일 수 있는 경로를 다르게 하고싶다면 navigation 윈도우의 agents탭으로 들어가서 agent타입별로 설정을 해주면 된다.

<br>

### 목적지의 설정

해당 navMesh를 이용하여 경로를 탐색하려면 우선 NavMeshAgent 컴포넌트가 필요하다.

해당 컴포넌트를 가지고 있는 오브젝트는 navMesh를 이용할 수 있게 된다.

<hr>

이제 목적지를 지정하기 위해서는 스크립트를 다룰 필요가 있다.

스크립트를 하나 연결한 뒤, 다음과 같은 코드가 필요하다.

```cs
using UnityEngine.AI;

NavMeshAgent ag;

public void SetDest(Vector3 _dest){
    ag.destination = _dest;
}
```

에이전트 컴포넌트를 따로 가져온 뒤에 destination 속성에 목적지 좌표를 지정해준다면, 해당 오브젝트는 지정된 목적지를 향하여 navMesh를 통해 경로탐색을 하게 된다.

<hr>

#### 주의점.

목적지를 지정하는 동작은 `update 내부에 작성하는것은 피하도록 하자`

매 프래임마다 경로를 탐색하는것은 매우 연산을 많이 잡아먹을것이다.

따라서 목적지가 변했을 경우에만 탐색을 진행한다던가
플레이어를 쫓아오거나 하는 경우에는 코루틴등을 이용해서 일정 주기마다 목적지를 갱신하여 갱신 주기를 벌려주는것이 좋다.

<br>

#### 에이전트 정지

경로탐색을 일시정지하는 등의 동작을 시키고싶다면 다음과 같은 코드를 사용할수 있다.

`ag.isStopped = [ true / false ];`

true일때는 멈출것이고, false일때는 움직일 것이다.

<br>

### 영역의 지정과 가중치

네비게이션 매시를 구성할 때에는 지나게 되는 오브젝트(바닥)영역들을 구분해서 지정해줄 수 있다.

오브젝트를 선택한 뒤 navigation 윈도우에서 object탭을 누르게 된다면, 해당 오브젝트의 영역을 지정할 수 있다.

각 영역은 navigation 윈도우의 area탭에서 생성하고 이동 비용 가중치를 설정할 수 있다.

이렇게 영역을 설정하게 된다면, 각 agent 컴포넌트로 이동하여 **이용할 수 있는 영역과 이용할 수 없는 영역을 지정해줄 수 있다.** 

예를들어 플레이어는 water영역을 통과할 수 있고, 몬스터는 water영역을 통과할 수 없게 만들수도 있다.

<br>

## NavMesh의 구성요소

NavMesh의 구성요소들을 알아보고 각 요소에 대하여 이해해보도록 하자.

<br>

### NavMesh
bake를 이용해 구성된 지나다닐 수 있는 영역을 의미한다. agent들은 navMesh영역들을 기반으로 길찾기를 진행한다.
<br>

### NavMeshAgent

네비매시로 이루어진 맵을 이용하여 경로 탐색을 진행할 객체를 의미한다.

해당 객체는 navMeshAgent컴포넌트를 가지고 있으며, 목적지를 지정하여 경로 탐색을 진행한다.

<br>

### NavMeshObstacle

navMesh에서의 방해요소를 구성한다.

navMesh는 bake를 통해 mesh를 미리 구성해놓는다고 했다.

하지만, 문이 열렸다 닫혔다 하는등의 이동 경로가 동적으로 바뀌는 상황이 있을 것이다.

해당 컴포넌트를 가진 객체가 navMesh를 가리게 된다면, bake된 해당 mesh영역을 제거하는 효과를 가지게 된다.

이렇게 동적인 경로수정이 가능하지만, 어디까지나 경로탐색을 동적으로 재계산하게 하기 때문에 많으면 많을수록 연산량이 크게 늘어날것이므로 주의해야 한다.

<br>

### OffMeshLink

bake에 의해서 뛰어넘을 수 있는 구간을 지정하다보면, 뛰어넘을 수 있는 모든 구간에 대하여 이동 가능 경로라고 판단하게 된다.

다만, 강이 존재하지만, 해당 강을 뛰어넘을 수 있는 지점을 한군데만 지정하고싶을 수도 있다.

이럴 때 두 지점간의 경로이동이 가능함을 명시적으로 정의해주는 요소가 OffMeshLink 컴포넌트가 되겠다.

해당 컴포넌트를 장착해주고 출발지점, 도착지점의 트랜스폼을 지정해주면 해당 경로간의 이동이 가능해진다.

<br>
