# URP와 셰이더

유니티에는 여러가지 랜더링 파이프라인이 있다.
그 중, 이번에는 urp에 대해서 알아보자. 

<br>

## 랜더링 파이프라인

유니티에서는 다음과 같은 파이프라인을 제공한다.

- Built-In render pipeline : 유니티에 기본적으로 설정되어있는 파이프라인, 범용성을 우선적으로 한 파이프라인이기 때문에 수정이 어렵고 성능이 다른 파이프라인에 비해 떨어지는 편이다.

- Universal render pipeline : 사용자가 그래픽 요소를 커스텀할 수 있는 파이프라인으로 최적화와를 할 수 있고, 그래픽도 좋게 표현할 수 있다.

- HD(high definition) render pipeline : 오로지 고사양과 고퀄리티의 그래픽을 위한 랜더 파이프라인. 개발과 출력 플레이 둘 다 높은 기기 성능을 요구한다.

<br>

## built-in의 URP로의 전환

built-in으로 진행하던 프로젝트를 URP프로젝트로 변환해야하는 상황이 있을 수 있다. 해당 방법을 알아보자.

<br>

1. 패키지매니저에서 universal RP 패키지를 임포트한다.
2. URP폴더를 하나 생성한다. **[선택사항]**
3. Create -> Rendering -> URP Asset with [2D / URP] 파일을 생성한다.
4. URP Asset, URP Asset Renderer 두개의 파일의 생성을 확인한다.
5. Project Settings -> Graphics 의  Scriptable Render Pipeline Settings항목에 생성된 URP Asset 파일을 연결해준다.
6. 해당 작업을 완료한다면, 기존의 오브젝트들이 magenta색상으로 변경될 것이다. 이 문제를 해결해야 한다.
7. window -> Rendering -> Render Pipeline Converter를 선택한 뒤, 변경할 랜더링 과정을 선택한다.
8. 변환할 항목들을 모두 체크하고 Initialize Converters를 누른다.(대부분 모든 항목을 체크한다.)
9. 우측 하단의 Convert Assets 버튼을 누른다.
10. 프로젝트 파일들에 Settings 폴더가 생겼음을 확인한다.

해당 파일들을 설정하여 그래픽 등급마다의 세부 설정을 할 수 있으며, 프로젝트 세팅의 품질(quality)항목으로 가서 품질을 설정할 수 있다.

**해당 품질들의 변경은 다음 코드로도 가능하다.**
`QualitySettings.SetQualityLevel([레벨 정수]);`

<br>

### 변경점

urp로 넘어가면 built-in과의 몇가지 차이점이 생긴다.

- material : 겉면을 그리는 방법등을 선택할 수 있게 된다.
- camera : 카메라 stacking이 가능해진다. ( 카메라 장면을 ui를 덮어그리듯이 출력하는게 가능해짐 )

<br>
## URP의 그래픽 요소

그래서 URP를 왜 사용하느냐? URP에서 사용할 수 있는 기능들이 있기 때문이다.

무슨 기능들이 있는지 알아보자.

<br>

### 커스텀 URP Renderer [ 실루엣 ]

URP는 사용자가 그래픽 요소를 커스텀할 수 있다고 했다.

이러한 특징을 이용하여 새로운 랜더러를 작성하기도 하고 이를 통하여 벽 너머에 있는 특정 오브젝트의 실루엣을 비추는 기능을 만들수도 있다.

<hr>

1. 프로젝트 창 -> Create -> Rendering -> URP Universal Renderer를 생성한다.
2. 해당 urp renderer의 인스펙터에서 Add Render Feature를 눌러 **Render Object**를 추가한다.

이제 해당 속성들을 다뤄가며 실루엣과 밝혀내는 기능들을 구현해보자.

<hr>

#### 실루엣

실루엣의 구현은 다음과 같다.

1. 우선 정상적으로 그린다.
2. 그려진 뒤에 해당 물체가 그려지지 않은 부분이 있는지 확인한다.
3. 그려지지 않은 부분을 **Depth**항목을 체크하여 확인하고, 가려진 경우를 판단하는 항목인 **Greater**를 선택한다.
4. 가려진 부분이 그려지게 된다.

+) 가려진 부분은 다른 머터리얼로 그리고싶다면 depth위에 override에 material을 추가하면 된다.

<hr>

#### 매직 미러

돋보기로 비추면 숨겨져있던 물체가 보이는 기능을 본적이 있을 것이다. 이러한 기능을 어떻게 구현하는지 알아보자.

stancil 기능을 사용할 것이다.

1. 가장 위로 가서 opaque layer mask에서 숨기고 싶은 layer를 지정해서 처음부터 그리지 않게 만들어준다.
2. 돋보기의 역할을 할 렌더러를 URP Universal Renderer의 Add Renderer Feature을 통해 만들어준다.
3. 해당 Render Objects의 Filters에 있는 Layer Mask를 돋보기 필터 역할을 할 레이어로 지정해준다.
4. 매직 미러 영역은 기본적으로 그려져 있으므로 이전 랜더링 상황에 상관없이 스텐실을 설정하기 위해 **스텐실을 체크**해주고, **Compare Function**을 Always로 바꾸어주고, 설정에 따라 **Pass**의 설정을 바꾸어준다. [ value로 값을 덮어쓰고싶다면 **Replace**항목으로 바꾸어준다.]
5. 위의 설정을 해석하고 현재 스탠실의 값을 점검해본다면, 랜즈 역할을 하는 레이어의 스탠실 테스트는 언제나 통과하므로 value의 값과 관계없이 Pass의 뒤의 동작을 수행한다.
6. 예를들어 스탠실 value의 값을 4로 설정해놓았다면, 해당 오브젝트의 랜더링이 끝난 뒤에는 스탠실의 값이 **4 ( value )**가 된다.
7. Add Renderer Feature를 통해 숨겨진 물체를 그려줄 렌더러를 새로 생성해준다.
8. 그려줄 물체는 우리가 볼 수 없을때에만 즉, 무언가에 가려져있을때에만 그려줄 것이다.
9. 따라서 **Depth**를 체크해준 뒤, **Depth Test**를 **Greater**로 바꾸어준다. 이는 무언가에 가려져서 보이지 않을 때 다시 그리겠다는것을 의미한다.
10. 다만 한가지 조건으로써 **현재 픽셀을 그릴 때** 앞서서 그린 **랜즈 역할의 오브젝트**를 그렸을 때에만 해당 물체를 그려야 한다.
11. 앞선 랜더링 과정에서 랜즈에 해당하는 물체가 **그려졌다면 스탠실이 4 (value)가 되었을 것이고**, 만약 그려지지 않았었다면 **스탠실이 0 ( 또는 처음 설정한 값 )** 일 것이다.
12. 따라서 현재 스탠실의 값이 **4 (value)** 라는 것은, 렌즈의 위에 그려지는 픽셀임을 의미하며, 스탠실의 통과 조건을 설정하면 된다.
13. 스탠실의 **value**를 **4(value)** 로 설정하고. **Compare Function**을 **Equal**로 지정한다.
14. 이렇게 하면 랜즈 역할을 하는 물체를 통해서 숨겨진 물체를 보는 경우에만 해당 물체가 보이도록 할 수 있다.

<br>

### Post Processing

전역적으로 또는, 영역별로 후처리 효과를 지정할 수 있다.

`우선 해당 기능을 위해서는 카메라의 Post Processing 항목을 체크해줘야 한다.`

그렇게 하기 위해서는 글로벌 또는 영역별 볼륨이 필요한데 천천히 순서에 따라 후처리 효과를 줘보도록 하자.

- 인스펙터에서 Create -> Volume 항목을 통해서 볼륨 영역을 생성할 수 있다.

해당 볼륨 영역에 들어가면 기존 global 볼륨에서 영향을 받던 빛의 반사, 물체의 일렁거림등을 조정하도록 할 수 있다.

이를 위해서는 각 볼륨마다 **Volume Profile**이 필요하다.
해당 파일은
`프로젝트 -> Create -> Volume Profile`을 통해서 생성 가능하며, 각 속성과 옵션은 해당 프로필에서 **Add Override**를 통하여 후처리 효과를 적용시킬 수 있다.

<br>

### 쉐이더

URP를 사용하게되면 어느정도 쉐이더를 작성할 수도 있다.

프로젝트에서 원하는 종류의 Shader파일을 생성하게 되면 머터리얼에 해당 쉐이더를 적용할 수 있게 된다.

<hr>

커스텀 쉐이더의 경우 그래프를 열어 편집할 수 있는데, 이곳에는 각각 변수를 정의하고 작성할 수 있다.

이를통해 동적으로 쉐이더가 변화하거나 자글거리거나 점점 투명해지는 등의 쉐이더 변화를 동적으로 다룰 수 있다.

<br>