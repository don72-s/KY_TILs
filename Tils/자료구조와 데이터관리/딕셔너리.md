# 딕셔너리

지금까지 여러가지 자료 구조를 보았다. 이번에는 [탐색]에 특화된 자료구조를 살펴보자.

## 해시 테이블

지금까지 저장된 데이터를 찾을때에는 순서에 기반한 정수 인덱스를 이용하여 접근하거나, 저장된 데이터의 인스턴스를 따로 빼놓고 접근했었다.

그렇다면 조금 직관적으로 데이터를 저장하는 방법은 없을까?

### 키와 값

데이터를 저장할 때, 그 데이터를 식별할 수 있는 역할을 **정수 인덱스**가 아니라 **식별을 위한 역할을 하는 변수**를 추가로 저장하는것은 어떨까?

예를들어 **"홍길동"** 이라는 이름 문자열과 **"010-xxxx-xxxx"** 라는 데이터를 저장해 놓는다면?

데이터를 찾을 때 정수 인덱스 또는 전화번호를 미리 가지고 있지 않더라도 `"홍길동"`이라는 식별 문자열만 제공한다면 데이터를 찾아올 수 있다.

이렇게 실제로 저장된 데이터를 **값**이라고 하며, 해당 값에 대응하는 인덱스 역할의 변수를 **키**라고 한다.

### 내부 동작 구조

키를 기반으로 한 빠른 값 접근 구조를 구현하기 위해서는 데이터에 바로 인덱싱 할 수 있어야 한다. 즉, 키를 기반으로 한 탐색이 이루어지지 않고 바로 데이터에 접근할 수 있어야 한다는 뜻이다.

전화번호를 **키**로 사용하고, 대응되는 이름을 **값**으로 사용하는 해시 테이블을 생각해보자.

조금 극단적인 예가 될 수 있겠지만, 다음과 같이 배열로 나타낼 수 있다.

`name[01012345678] = "홍길동";`

분명 인덱스를 이용한 데이터 접근은 그 어느 방법보다 빠르다.

하지만 배열의 크기는 얼마나 커야할까...
**2백억개** 정도 크기의 배열이 필요할 것이다..

### 해싱

할당해야 할 공간이 너무 많다. 그래서 키를 약갼 간소화 해서 전체 저장공간을 줄여보기로 한다.

휴대폰 번호 전체를 키로써 사용하기보다는, 가장 뒷번호 4자리만 인덱스로써 사용하자는 이야기다.

이렇게 생각해보자.

`name[5678] = "홍길동";`

이렇게 키의 범위를 줄인다면, 배열에 할당되는 전체 메모리 크기는 확실히 작아질 것이다.

이와 비슷하게 **키** 데이터를 **대응되는 일정한 길이의 다른 키 값**으로 변환시키는 행위를 `해싱`이라고 한다.

```
010-1234-5678 => 5678
010-4457-8432 => 8432
등등...
```

기본적으로 해싱 결과의 범위는 저장공간의 배열 크기의 인덱스 범위로 제한한다.

### 충돌

전화번호는 사람마다 고유한 값이지만 **뒷자리만**본다면 중복되는 사람이 존재할 가능성이 있다.

더 많은 양의 데이터를 더 적은 양의 데이터로 구겨넣기 때문에 반드시 발생할 수 있는 현상이다.

발생할 가능성을 없앨 수 없다면, 일어났을 경우의 대비책을 만들어놓아야 한다.

<br>
### 충돌 회피

다음과 같은 데이터 저장 요청이 순차적으로 들어왔다고 가정해보자.

```
010-1234-5678 , 홍길동 => (5678, 홍길동)
010-4457-5678 , 김서방 => (5678[충돌], 김서방)
```

분명 원래 키값은 다른값인데 해시값은 중복된다.

즉, 5678번지에 "홍길동"을 저장한 뒤에
다시 5678번지에 "김서방"을 저장하려 보니까 이미 데이터가 있었던것이다.

원본 키값이 **같았다면** 데이터를 덮어쓰면 괜찮겠지만, 원본 키값이 다르기 때문에, 덮어쓰면 의도와 다르게 동작하는 것이다.

그렇다면, 데이터를 저장하는 곳에 키에 대응되는 값만 저장하지 말고 더 많은 데이터를 저장하는건 어떨까?

배열의 각 공간에는 다음과 같은 데이터들이 저장된다고 생각해보자.

```
원본 키 | 값 | 다음 데이터 주소
```

다시 처음부터 생각해보자.
첫 데이터 삽입 시에는 무난하게
`(0x1123) 010-1234-5678 | 홍길동 | null`
과 같은 데이터가 저장될 것이다.

여기서 다음 데이터가 들어온다면?
`(0x1123) 010-1234-5678 | 홍길동 | 0x????`
`(0x????) 010-4457-5678 | 김서방 | null`

다른 공간인 **0x????** 에 저장한다고 가정하자.

최초 탐색 시에는 "홍길동"이 저장된 0x1123으로 이동하여 충돌이 일어나겠지만, 원본 키에 대한 데이터를 가지고 있으므로 원본 키 비교를 통해 "김서방"에 대응되는 값이 아님을 시스템이 알 수 있다.

따라서 다음 데이터 위치를 가리키는 0x????공간에 "김서방" 데이터를 저장하고, 해당 주소를 **"홍길동"** 의 **[다음 주소]** 에 저장하는것으로 충돌을 회피할 수 있다.

그렇다면 어떻게 **0x????** 의 위치를 정할까?

대표적으로 다음과 같은 두가지 방법이 있다.

* 체이닝
* 개방주소법
<br>

### 체이닝

##### c++에서 사용중인 방법.


`(0x1123) 010-1234-5678 | 홍길동 | null`
위의 해시값에 대한 충돌이 발생한 경우
**새로운 공간에 메모리를 할당**하여 저장한다.

이렇게 체이닝된 데이터들은 연결리스트(linkedList)의 구조로 관리되며 삽입 삭제가 빈번하게 일어나더라도 시간/공간복잡도에 크게 영향을 끼치지 않는다.

`다만 이는 c++이기 때문에 효율적인 구조`이며

GC가 존재하는 언어 [c# 등등] 의 경우에는, 메모리를 직접 해제할수가 없기 때문에 충돌된 데이터의 삽입 / 삭제가 빈번하게 발생할 경우, 파편화된 메모리 데이터들이 많아져 GC의 수거량이 많아지므로 메모리를 직접 해제할 수 있는 언어인 C++에서 사용하고 있는 기법이다.

### 개방주소법

##### GC언어에서 사용하고 있는 기법


`(0x1123) 010-1234-5678 | 홍길동 | null`
위의 해시값에 대한 충돌이 발생한 경우
채택한 규칙에 따라 **해시테이블 내의 빈 공간**을 찾아서 해당 공간에 저장한다.

처음 할당된 데이터테이블 배열 내부에서 할당할 수 있는 공간을 찾는 구조이기 때문에 충돌에 의한 **새로운 메모리 할당 / 기존 메모리 해제**가 일어나지 않는다.

즉, 직접 메모리 해제가 불가능한 `GC기반 언어`에서 채택하고 있는 기법이 되겠다.

다만, 충돌이 일어난 데이터중, 첫번째 데이터를 완전히 제거한 뒤에 다시 사용할 수 없다.
다시말하면 `한번 사용된 공간을 재사용할 수 없다.`

이유인 즉슨, 홍길동, 김서방 순서로 충돌이 일어나는 데이터를 저장했는데, 홍길동 데이터가 삭제되어 해당 공간을 재사용할 수 있는 상황이라고 하자.

만일 여기서 김서방과 같은 데이터를 실수로 또다시 저장하려고 한다면, 같은 키가 이미 저장되어 있으므로 오류가 나야한다.

하지만, 최초 해싱에 의해 홍길동이 저장되었던 위치를 가리키게 될 것이고, **재사용이 가능**하다면 중복키에 의한 저장이 일어날 것이다.

따라서 `저장공간의 재사용이 불가`하며, 이러한 특성으로 인해 **잦은 삽입 / 삭제**가 일어나는 데이터를 저장하는 용도로 사용하게 된다면, 메모리 사용량이 폭발하는 불상사가 일어날 수 있으므로 삽입과 삭제가 빈번히 일어나는 데이터라면 사용을 신중히 고려해보아야 한다.

또한, 통계적으로 분석해보았을 때 데이터를 저장할 공간을 찾는 경우 (충돌 발생 여부와 관계 없이) 테이블이 **사용중이거나 사용되었던** 공간의 비율이 테이블 크기의 70%가 넘어가는 경우, 삽입 효율이 급격하게 떨어진다고 한다.

이러한 사실 때문에, 내부적인 구현에서는 사용 가능 공간이 30% 미만으로 남아있을 때에는  테이블의 크기를 확장하고, 활성화되어 있는 데이터(제거되었던 데이터는 버린다)들을 새로운 테이블에 재해싱하여 옮긴다.

