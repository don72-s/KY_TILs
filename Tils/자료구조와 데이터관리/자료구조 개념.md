# 자료구조

자료구조란, 자료를 저장하는 구조를 말한다.
필요한 여러가지 종류의 데이터들이 있을 때, 단순히 퍼뜨려놓는것이 아니라 사용하는 용도에 따라
찾아쓰기 편하도록 정리해서 보관해 놓을 필요가 있다.

이러한 상황을 위해 생겨난 개념이 자료구조이다.

<br>

## 데이터의 분포

데이터가 어떤 방식으로 저장되어 있는지에 따라서 크게 두가지 종류도 나뉜다.
잠깐 데이터의 분포에 대해 알아보자.

<br>

### 선형 자료구조

선형 자료구조는 문자대로 데이터가 한줄로 서있는듯한 모양으로 저장되어있는 구조를 말한다.

일자로 저장되기 때문에 시작과 끝(머리와 꼬리)가 명확하고, 각 데이터는 꼬리를 제외한다면
하나의 다음 데이터를 가지고 있는 구조를 말한다.

대표적으로 스택, 큐, 배열, 연결리스트 등을 들 수 있다.

<br>

### 비선형 자료구조

비선형 자료구조는 선형 자료구조와 다르게, 데이터간의 관계가 1 : n 또는 n : n 의 관계를 가지고 있는
데이터 구조를 말한다.

정렬된 데이터보다는 서로 연관있거나 데이터간 이동 가능한 등의 관계를 가지는 데이터 구조를 표현하는데에
사용하기 적합한 자료구조이다.

대표적으로 그래프, 트리가 있다.

<br>


## 복잡도

우리가 물건을 정리하는 이유는 효율적으로 공간을 사용하기 위해서, 그리고 필요할 때 빠르게 찾기 위해서이다
컴퓨터에서 데이터를 저장할 때 어느 자료구조로 저장할지에 대한 선택도 같은 고려사항을 가지게 된다.

<br>

### 공간 복잡도

프로그램의 로직을 돌리는데에 필요한 저장공간, 메모리의 크기를 기준으로 측정하는 복잡도이다.

예를 들어서 피보나치 수를 찾는 함수를 생각해보자.

이 함수를 내부 반복문으로 돌린다면 함수 콜스택의 깊이는 1일 것이고 사용되는 변수도 내부 지역변수로 한정될 것이다.
반대로 재귀함수를 사용한다면 함수 콜스택은 n번째 피보나치 수를 찾는만큼 함수 콜이 이루어지므로 콜스택의 깊이가 n이 될 것이다.

같은 기능을 다르게 구현했을 뿐인데, 최대로 요구되는 메모리의 크기가 크게 차이가 난다.

이렇게 저장공간을 고려한 복잡성을 표기한 것을 **공간 복잡도** 라고 한다.

다만 하드웨어의 발전으로 임베디드 프로그램같이 메모리를 주의깊게 신경써야 하는 경우가 아니라면 요즘에는 예전에 비해 주의도가 많이
옅어진 편이다.

<br>

### 시간 복잡도

시간복잡도는 프로그램이 로직을 완료하는데 소모되는 시간을 기준으로 측정하는 복잡도이다.

하지만 해당 척도는 객관적으로 일관적인 수치로 도출해내는것이 불가능하다.
컴퓨터 성능에 따라 소요시간은 천차만별이기 때문이다.

따라서 알고리즘의 시간 복잡도를 대략적으로 표기하는 방법인 **빅오 표기법** 을 사용하여
시간 복잡도를 표현한다.

<br>


### 빅오 표기법

빅 오 표기법이란, 알고리즘을 실행하는 동안, 입력되는 데이터에 따라 각 구문블록별로 몇번의 연산이
이루어지는지를 각각 표기한 뒤, n을 제외한 상수들은 모두 1로 대치시킨 후, 가장 증가폭이 큰 연산 횟수만을
괄호 안에 작성하는 표기법이다.

개념에서 보이듯이, 특정 상황에서의 비용을 책정하는 방법이 아닌, 최악의 상황에서의 비용을 기준으로 복잡도를
책정하는 방식이 되겠다.

빅 오 표기법은 다음과 같이 표기한다.
`O( 가장 증가폭이 큰 블록의 연산 횟수 )`

다음과 같은 예시를 보자.

```cs
void Calc(int _n){

    int[] arr = new int[n];                                // O(1)
    
    for(int i = 0; i < arr.Length; i++){ arr[i] = i; }     // O(n)
    
    arr[ _n / 2 - 1] = -27;                                // O(1)
    
    for(int i = 0; i < arr.Length; i++){                   // O(n^2)
        for(int j = 0; j < arr.Length; j++){
            arr[i] += arr[j];
        }
    } 

}
```

각 구문 블록별로 예상 시간 복잡도들을 주석으로 표기했다.

Calc함수를 실행하면 위의 시간복잡도들을 모두 합한 시간을 소모할 것이다.
그렇다면 여기서 Calc의 시간 복잡도를 표현하자면 다음과 같을 것이다.

`O(n^2 + n + 2)`

여기서 빅오 표기법의 표현방식에 의하면 가장 큰 증가폭을 가진 연산만 남긴다.
따라서 최종적으로 다음과 같이 남을 것이다.

`O(n^2)`

이유는 n이 무한대로 커진다고 한다면, n^2의 크기를 생각한다면 n번의 연산속도는 눈에 들어오지도 않을 것이다.
이러한 이유로 가장 증가폭이 큰 연산만 남겨놓고 나머지는 다 없다고 생각하는 형식으로 표기하는 것이다.


<br>