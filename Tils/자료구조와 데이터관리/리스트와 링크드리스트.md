# 리스트와 연결리스트

지금까지 여러개의 데이터를 저장할때는 배열을 사용했다.
하지만 배열에는 단점이 있었다.

초기에 배열의 크기를 지정해야 하며, 이후에는 크기를 바꿀 수 없었다.

그렇다면 이러한 한계를 개선한 자료구조는 없을까?

원래는 직접 구현했어야 하지만, 최근에는 대부분의 개발 환경에서 자료구조를 제공한다.

여기서는 리스트와 연결 리스트에 대해 알아보자.

<br>

## (순차)리스트

c#에서 정의되어있는 List< T > 타입을 사용하기 위해서는 System.Collections.Generic 네임스페이스를 using해야 한다.

namespace를 using했다면, List< T > 타입의 클래스 인스턴스를 만들어서 사용하면 된다.

또한 순차 리스트의 특성으로써, 메모리에 연속적으로 데이터 공간이 할당된다.
다만, 우선 지정된 배열의 크기를 넘어서 데이터를 추가하려 한다면, 기존 메모리보다 더 큰 메모리를 재할당하고
기존 객체의 데이터를 복사한 뒤, 이전 인스턴스를 제거하는 과정을 거치므로 사용할 최대 크기를 정해놓고 해당 크기를
넘지 않는 선에서 이용하는것이 바람직하다.

<br>

### 내부 메서드

List< T > 클래스에서는 내부 데이터를 다루는 여러가지 함수를 제공한다.
또한 배열과 같이 [ idx ] 를 이용하여 특정 위치에 값에 바로 접근할 수 있다.

**Add( data )** : 리스트의 끝부분에 데이터 data를 추가한다.
**Remove( data )** : 리스트에서 해당 데이터를 찾아 제거한다. 선형탐색을 기반으로 한다. + 제거된 뒤, 뒤에 있는 요소들을 당겨와야 한다( (O(n) )
**RemoveAt( idx )** : idx위치에 있는 요소를 제거한다. 다만 제거된 뒤, 뒤에 있는 요소들을 당겨와야 한다( O(n) )
**Insert( idx, data )** : idx위치에 data를 삽입한다. 추가하기 위해 뒤에있는 요소들을 뒤로 밀어야 한다( O(n) )

이외에도 여러가지 기능의 함수들이 존재한다.

<br>

## 연결리스트

지금까지 봐왔던 순차리스트와 배열은 메모리에 데이터를 연속적으로 저장했다.
이 방법은 특정 자료에 접근하는데에는 매우 유리했지만, 데이터를 추가, 삭제하는데에 상대적으로 큰 비용이 필요했다.

그렇다면 참조형식이라는것을 응용해서 **논리적으로는 선형적** 데이터이지만, **물리적으로 연속적이지 않은** 리스트를 만들 수 있지 않을까?

<br>

### 노드와 참조

연결리스트는 각각의 배열 요소를 **노드**라는 객체로 취급한다.

각각의 노드는 기본적으로 요소의 정보 외에도 **다음 노드의 주소를 가리키는 변수**를 추가로 가진다.
리스트의 종류에 따라, 이전 요소의 노드를 가리키는 변수를 추가로 가지기도 한다 (이중연결리스트)

<br>


### 할당 방식과 특징

노드와 포인터 방식으로 구현되어있기 때문에 전체 데이터 크기가 아무리 많아도 리스트처럼 메모리가 2배로 새로 할당되거나 하는 일은 발생하지 않는다.
언제나 **값 하나 분량의 데이터공간**만 할당하고, 이전 노드가 새로운 노드를 **다음 노드입니다.** 하고 가리키는 형태로 배열의 크기가 늘어난다.

                  ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐ 
                  │ │ C │ │                    ┌───│ C │───┐                  ┌───│ C │───┐
                  └─┴───┴─┘          =>        ↓ └─┴───┴─┘ ↓        =>        ↓ └─┴───┴─┘ ↓
         ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐ ↑     ↑ ┌─┬───┬─┐
         │ │ A │←───────────→│ B │ │    │ │ A │←───────────→│ B │ │    │ │ A │───┘     └───│ B │ │
         └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘


반대로 데이터를 제거할 때에도 비용이 적게들게 된다.

단방향 연결리스트의 경우에는 제거할 데이터의 앞에 있는 노드가 가리키는 **다음 노드 주소**를 단순히 **다다음 노드 주소**로 바꾸어주면 된다.
         
                  ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐
                ┌──→│ C │←──┐                    │ │ C │←──┐                    │ │ C │ │
                │ └─┴───┴─┘ │        =>          └─┴───┴─┘ │        =>          └─┴───┴─┘
         ┌─┬───┬│┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐
         │ │ A │↓│         │↓│ B │ │    │ │ A │──────────→│↓│ B │ │    │ │ A │←───────────→│ B │ │
         └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘


그럼 삭제 대상이 된 노드를 가리키는 변수가 없어 gc에 의해 해제될 것이고, 원래 삭제된 노드를 가리키던 변수는 삭제된 노드의 다음 노드의 주소를
가리키고 있기 때문에, 이후에 있는 데이터들을 한칸씩 밀어줄 필요가 없다.        


<br>

### 내부 메서드

LinkedList< T > 클래스 또한 내부 데이터를 다루는 여러가지 함수를 제공한다.

다만, 연속된 데이터가 아니기 때문에 `인덱스를 이용한 접근이 불가능하다.`
<br>

#### 양 끝에 추가
<hr>

**AddFirst( data )** : 연결리스트의 가장 앞부분에 데이터 노드를 추가한다.
**AddLast( data )** : 연결리스트의 가장 뒷부분에 데이터 노드를 추가한다.

연결 리스트의 노드에는 노드로써 사용하는 특정한 타입이 존재한다.
 `LinkedListNode`라는 타입을 이용하여 노드를 구성하며, 위의 AddFirst, AddLast의 반환값으로 추가된
LinckedListNode타입의 저장된 인스턴스의 주소를 반환한다.
<br>
#### 삽입
<hr>

이런식으로 노드를 반환하는 이유는, 중도 삽입 연산을 위해서 **인덱스를 사용할 수 없기** 때문이다.
따라서 중간에 삽입을 하기 위해서는 해당 노드가 어떤 노드인지 알아야 하기 때문에 매개변수로 LinkedListNode타입의 인스턴스 주소를 전달해야 한다.

삽입 함수의 예시는 다음이 있다.

**AddBefore( LinckedListNode, data)** : 첫번째 매개변수인 노드의 앞부분에 전달된 데이터를 삽입한다.
**AddAfter( LinckedListNode, data)** : 첫번째 매개변수인 앞부분에 전달된 데이터를 삽입한다.

`단, 여기서 단방향 연결리스트는 [AddBefore]를 지원하지 않는다.`

단방향 연결리스트에서의 before삽입을 위해서는 **원하는 위치의 노드** 와 **그 이전 위치의 노드** 정보가 필요하다.
**이전 노트가 가리키는 주소를 추가될 데이터의 주소**로 바꾸어주어야 하기 때문이다.

때문에 선형 탐색을 필요로 하므로 그냥 **addAfter**를 사용하는게 O(1)이 되므로 addbefore를 지원하지 않는다.

<br>
#### 제거
<hr>

같은 원리로 LinkedListNode타입을 전달받으면 삭제도 가능하다.
삭제에 대응하는 함수는 다음과 같다.

**RemoveFirst()** : 연결리스트의 첫번째 노드를 삭제한다.
**RemoveLast()** : 연결리스트의 마지막 노드를 삭제한다.

**Remove( LinkedListNode )** : 연결리스트에서 해당 노드를 삭제한다.
`다만 삽입과 같은 원리로, 단방향 연결리스트에서는 시간복잡도가 O(n)이고, 양방향 연결리스트에서는 시간복잡도가 O(1)이다.`

<br>