# 오브젝트 풀

오브젝트의 생성과 파괴에서 언급했지만, 과한 생성/삭제는 문제가 될 수 있다고 했다.

하지만 생성/삭제를 하지 않고 게임을 개발한다는것은 사실상 불가능하다.

이러한 문제를 완화시키기 위하여 나온것이 오브젝트 풀 패턴이다.

<br>

## 원리

자주 사용되는 객체를 **초기화 가능**한 형식으로 작성한 뒤 미리 여러개를 만들어 놓은 후, 대여 / 반납 형식으로 생성 / 삭제 동작을 대체한다.

<br>

### 대여 구현

대여 / 반납이 필요하므로 이를 저장할 자료구조가 필요하다.

물론 구현 방법은 자유이므로 배열이든 리스트든 제 역할을 할 수 있다면 뭐든 괜찮다.

간단하게 의사코드로 작성한다면 다음과 같다.
```cs
class ObjPool{

    List< 인스턴스 타입 > l;
    transform 부모;

    public ObjPool(초기 크기, 인스턴스 프리팹){
    
        l = new List< 타입 >(초기 크기);
        
        for(초기크기){ 
            
            l.Add(프리팹 인스턴스화, 부모);
            l.active => 비활성화 시키기;
            
        }
    }
    
    public 인스턴스 타입 GetObj(){
    
        for(i, l){
        
            if(l[i].activeself : 비활성화){
            
                ret = l[i]; => 활성화시킴
                l[i] => 부모 제거
                l[i] => l에서 제거
                return ret;
                
            }
        }
        
        //비어있는게 없는 경우
        return (프리팹 새로 인스턴스화)
    }
    
    public void Back(인스턴스){
        
        //반납용 코드
        인스턴스.active => false : 비활성화시킴
        l.Add(인스턴스);

    }

    public void DestroyPool(){
        
        for(i, l){
            Destroy(l[i]);
        }

    }

}
```

외부에서 요청하면 보관하고 있는 타입의 인스턴스를 제공하거나 반납을 받는다.

<br>

### 대상이 되는 프리팹

풀 스크립트만으로는 아직 부족한점이 존재한다.
인스턴스를 반환할 때, 어느 오브젝트 풀로 돌아가는지 알 수가 없다.

이를 위해 프리팹에는 복귀할 오브젝트 풀을 가지고 있기로 한다.

```cs
class InstType{

    오브젝트 풀 타입 pool;
    
    public InstType(풀 타입){
        pool = 풀 타입;
    }

    public void BackToPool(){
        pool.Back(this);
    }

}
```

위와 같이 설정할 수 있으며 오브젝트 풀에서 생성할 때, 본인을 인자로 넘겨줄 필요가 있다.

<br>