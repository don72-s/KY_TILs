# 생성자

클래스가 만들어질 때 기본으로 설정될 값을 지정해줄 수는 없을까?
이를 위해 존재하는 것이 생성자다.

<br>

## 생성자의 구조

생성자는 조금 특수한 함수 이므로 구조도 특수한 구조를 가진다.

생성자의 구조는 다음과 같다.

```cs
Class Car
{
    public Car(string _initName)
    {
        //생성자 내용...
    }
    
    public Car(int _initNum)
    {
        //생성자 내용...
    }

}
```

기본적으로 public 접근 작성하며 반환값은 생략한다. (void도 작성x) 그리고 함수의 이름을 **클래스의 이름과 같은** 이름으로 작성한다.

또한 매개변수의 종류와 타입이 다르다면 생성자를 여러개 정의할 수 있다.

<br>

## 기본 생성자

위와 같이 생성자를 작성한다면 이전과 같은 인스턴스화에서 오류가 발생할 것이다.
그동안에는 문제가 없었는데 왜 그럴까?

**기본 생성자** 의 존재때문이다.

생성자를 모르고 있었을 때에는 생성자를 명시적으로 작성하지 않았다면, 컴파일러가 다음과 같이 몰래
생성자를 작성하는것이다.

```cs
Class Car
{
    
    /* 이 부분이 자동으로 작성됨
    *
    *public Car(){ }
    *
    */

}
```

즉, 위의 생성자가 있다고 취급되었으므로 오류가 발생하지 않았다.

하지만 하나의 생성자라도 명시적으로 작성한다면 인스턴스화 할 때 반드시 명시된 생성자들 중
하나를 호출해야 한다.

따라서 위에 정의한 string, int가 매개변수로 포함된 생성자를 반드시 사용해서 초기화해야 하며
기존처럼 기본 생성자도 사용하고싶다고 한다면, 기본 생성자 형식의 생성자를
명시적으로 작성해주면 된다.

<br>

## 소멸자

만들어질 때가 있다면 사라질 때도 있다. c++과 같은 gc가 없는 언어에서는 한번 할당된 메모리를 직접 해제하지 않으면
자동으로 해제되지 않는다. c++의 영향으로 c#은 gc가 존재함에도 불구하고 소멸자가 존재한다.

소멸자는 할당된 인스턴스가 메모리에서 해제될 때 내부의 코드블록이 실행되는 특수한 함수이다.

소멸자를 작성하는 방식은 다음과 같다.
```cs
Class Car
{

    ~Car(){ //해제될 때 호출될 내용 }    

}
```

다만 소멸자에는 주의할 점이 있다.

호출 시기를 명확하게 알 수 있는 생성자와 달리, 소멸자는 호출 타이밍을 정확하게 알기 어렵다.

이는 c++과 gc의 문화충돌 같은 느낌인데 c++이었을 경우에는 소멸자에 본인이 할당받았던 메모리를 해제하는 작업을 주로 작성한다.
이는 해당 객체를 가리키는 포인터의 수가 0개가 되는 순간 소멸자를 호출하기 때문에 객체가 고립되는 순간 바로 소멸자를 호출하게 된다.

하지만 c#은 gc를 통한 메모리 할당을 이용하기 때문에 소멸자가 호출되는 타이밍은 gc가 동작하여 해당 객체가 고립됨을 확인한 뒤, 메모리를
해제하는 순간 소멸자가 호출되는것이다.

그렇다고 소멸자 하나를 호출하기 위해서 gc를 호출하는것은 생각보다 비용이 많이 들기 때문에 후술할 dispose를 더욱 자주 사용한다.

<br>

## IDisposable과 Dispose

위의 소멸자의 역할을 대체하기 위해 나온것이 IDisposable 인터페이스다.

다른곳에서는 자주 사용되지 않고 보통 using 키워드와 함께 사용된다.

using블록 안에서 인스턴스화된 객체가 IDisposable인터페이스를 상속받고 있다면, using블록을 나갈 때
자동으로 오버라이드 된 Dispose함수를 호출하게 된다.

<br>
` 그런데 왜?`
라는 의문이 자동적으로 생길 것이다.

결국 언젠가는 gc가 메모리를 회수해줄 것인데 굳이 dispose를 구현해가며 작성할 필요가 있을까?

이는 소멸자의 대체 역할에 있다.

c++에서는 소멸자에 메모리 해제 코드를 작성할 때 스택, 힙 등이 아닌 다른 메모리 해제까지 작성했었다.

다만, **관리되는 메모리** 라고 불리는 스택, 힙 등의 영역이 아닌 다른 메모리 영역에서 사용되는 자원이 존재한다.
이 메모리들은 gc가 해제해주지 않으므로 소멸자를 이용해야 하는데 소멸자는 호출 시기를 알 수 없다.

이러한 **관리되지 않는 메모리** 들은 즉각즉각 사용 종료 후 바로 해제가 필요한 경우가 많기 때문이다.

그때문에 using 블록을 빠져나가 객체가 해제되는 순간이 명확한 시점에 호출되는 dispose함수를 이용하여
**관리되지 않는 메모리** 를 해제해주기 위해 사용되는 구문이다.


<br>


