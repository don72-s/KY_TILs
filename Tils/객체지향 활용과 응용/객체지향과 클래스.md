# 객체지향과 클래스

가장 처음 프로그래밍의 흐름인 절차지향 프로그램에서 역할에 따라 객체들이 나누어지는 객체지향
프로그래밍으로 프로그래밍 패러다임이 넘어왔다.

객체지향 프로그래밍이 무엇인지 자세히 알아보자.

<br>


## 객체지향

상술한 절차지향은 프로그램의 흐름을 이해하는 데에는 직관적이고 이해하기 쉽지만, 모든 기능이 엄격한
순서 흐름에 제어되어야 하므로 프로그램의 구조 자체가 복잡해진다.

이러한 절차지향 프로그래밍의 한계를 극복하기 위해 나온 패러다임이 객체지향 프로그래밍이다.

<br>

### 객체지향의 개념

절차지향과 다르게 객체지향은 프로그램의 흐름에 신경쓰기보다는 기능의 전문화 및 분리를 하는데에 더욱 중점을 둔다.

예를들어 입력, 계산 렌더링의 세가지 기능이 있다면 절차지향 프로그래밍에서는

` 입력 -> 계산 -> 렌더링 -> 반복... `

의 순서를 반드시 지켜야만 했다. 하지만 객체지향 프로그래밍에서는

순서대로 처리하기보다는 각 기능별로 담당자인 **객체** 들을 생성해두고 이 **객체간의 상호작용** 을 중심으로
프로그램의 내부를 구성하는 방식이다.

<br>

절차지향과 비교적, 개념적으로 설명하자면

특정 객체에게 행동을 시키고 싶을 때,

절차지향은 **함수에 행동할 객체** 를 전달하여 명령한다면,
객체지향은 **행동할 객체의 내부의 함수** 를 호출하는 식의

내부 구조의 차이를 가진다.

<br>

## 객체지향의 4대 특징

그렇다면 객체지향은 어떤 특징을 가질까? 가장 큰 4가지 특징에 대하여 간단하게 알아보도록 한다.

<br>

### 추상화 (Abstraction)

객체별로 어떤 행동을 할 수 있는지 외부에 제공하는것이 객체지향 프로그램이라고 했다.

하지만 외부에서 해당 객체의 모~~~든 기능을 볼 필요는 없다.

예를들어 자동차 객체가 있다면 사용자는 **시동 걸기** , **엑셀** , **브레이크** 등의 기능만 필요하지,
**냉각수 순환** , **매연 배출** 등의 내부동작이나 자잘한 행동들은 알 필요가 없다.

즉, 내부 동작과 불필요한 기능들은 숨기고 외부에서 필요로 하는 기능들만 개방하여 외부에서 보기에는
내부 로직의 복잡성과 구조에 상관없이 직관적이고 필요한 기능만을 공개하고 제공하는 특징을 말한다.

<br>

### 캡슐화 (Encapsulation)

객체지향의 구조가 제대로 동작하기 위해서는 각각의 역할이 명확하게 분리되어 있어야 한다.
이렇게 서로 관련된 데이터와 기능들을 하나의 객체로 묶어놓은 것을 **캡슐화** 라고 한다.

서로 관련있는 데이터들을 한데 모아둠으로써 관리와 사용이 용이해지고 이 데이터들을 외부에서
함부로 변경하거나 접근하는것을 방지할 수 있다. 이를 **정보 은닉** 이라고 한다.

물론 외부에서 필요로 하는 데이터나 함수만을 공개되도록 설정할 수도 있다. 이 때에는 접근제한자를 사용한다.

<br>

### 상속 (Inheritance)

현실세계에서는 포함관계나 범주와 같이 여러가지 종류의 객체들의 특징을 포함하는 상위 개념이 있는 경우가 많다.

예를 들어 트럭, 승용차, 버스는 모두 **자동차** 라는 상위 개념의 범주로 묶을 수 있다.

만일 위의 세 종류의 자동차를 객체로 설계한다고 했을 때, 분명 상위 범주를 가지기에 공통되는 기능들이 있을 것이다.
하지만 각 객체마다 **운전** , **시동걸기** 등의 기능들을 중복해서 작성하는것은 확실히 비효율적인 일이다.

이를 효율적으로 해결하기 위해 나온 개념이 **상속** 이다.

**자동차** 라는 객체를 만들고 **운전** , **시동걸기** 등의 공통되는 기능을 정의하고 하위 객체들은
이 객체들을 상속하게 만든다.

그렇다면 하위 객체들은 상속받은 상위 객체들의 기능들을 사용이 가능해진다(private 의 경우는 제외)
이를 통하여 코드의 중복을 줄여 재사용성을 높이고, 범주관계를 설계함으로써 구조적 포함관계를 확인하기 쉬워진다.

<br>

### 다형성 (Polymorphism)

상속의 응용적인 특성으로써 같은 객체로 취급되는 상황이지만, 상황과 취급에 따라 각자 다른 행동을 취하게 만들 수 있는 특징이다.

대표적으로 부모 객체로 이루어진 리스트에 객체들을 넣어놓고, 오버라이드된 함수들을 일괄적으로 호출하는등의 로직으로
같은 (부모)타입이지만, 어느 자식 객체가 해당 함수를 어떻게 오버라이드했는지 또는, 영향을 주는 속성들의 차이에 따라서

`하나의 행동을 호출하지만 상황에 따라 각자 다른 결과가 나타나는 특징을 다형성이라고 한다.`


<br>

## SOLID 원칙

객체의 구조를 설계하는데에 있어서 구조적 제한은 없다. 다만 언제나 과한 자유는 협력을 어렵게 만든다.
이를 위해 가능한 한 객체를 설계하는데에 있어서 5가지 원칙을 지켜주기를 권장하는데 해당 항목들은 다음과 같다.

<br>

### S : 단일 책임 원칙 (Single Responsibility Principle)
<br>
`'클래스(객체)는 단 하나의 책임만 가져야 한다. '`

즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 설계해야 한다.

관련있는 기능들을 모아놓는다고는 하지만, 하다보면 너무 이것저것 붙어있는 이도저도 아닌 객체가 될 수 있다.
그럴 기미가 보인다면 다시 기능별로 객체를 분리해는것이 권장된다.

<br>

### O : 개방 폐쇄 원칙 (Open Closed Priciple)
<br>
`'확장에 열려있어야 하며, 수정에는 닫혀있어야 한다.' `

기능 추가시 기존의 코드를 수정하기보다 추가적인 코드를 작성해 기능을 추가할 수 있어야 한다는 원칙이다.

문자 그대로 기존의 코드는 최대한 수정을 피해야 한다. 기존 코드를 수정한다면 기존 코드를 기반으로 돌아가는 기능들에 영향을
끼칠 가능성이 매우 크다.

따라서 기능을 추가할 때에는 기존 기능의 수정에는 매우 신중하게 대신, 기능을 추가할 때에는 기존 기능에 확장할 수 있도록 설계해야 한다.

<br>

### L : 리스코프 치환 원칙 (Listov Substitution Priciple)
<br>
`'자식 객체는 언제나 부모 타입으로 교체될 수 있어야 한다.'`

다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면 상위 클래스의 역할을
완전히 대체할 수 있어야 한다.

상속을 이용한 특징으로 자식타입 객체는 부모타입으로 형변환이 가능하다. 이런 특징으로 부모타입에 정의된 함수를 호출할 때
형변환된 자식 객체가 본체더라도 함수 호출 동작에 문제가 없도록 설계해야 한다는 원칙이다.

<br>

### I : 인터페이스 분리 원칙 (Interface Segregation Principle)
<br>
`'하나의 큰 인터페이스보다 용도에 맞는 인터페이스를 잘게 분리해야 한다.'`

프로그램의 유지보수에서 발생할 수 있는 인터페이스의 분리나 수정으로 인한 많은 양의 코드 수정을 막기 위해 불필요한 정보까지 
가질 수 있는 하나의 거대한 인터페이스보다, 상황에 맞도록 소규모로 분리된 인터페이스를 사용할 수 있어야 한다는 원칙이다.

인터페이스의 구성이 너무 범용적이라면 해당 인터페이스를 구현하는 측에서는 원하지 않는 기능도 구현해야 한다.

예를들어서 인터페이스가 다음과 같다고 하자.

```cs
interface IDriving{
    public void Drive();
    public void TurnOn();
}
```

위와 같은 인터페이스는 자동차가 구현한다면 문제가 없다. 하지만 자전거가 해당 인터페이스를 구현한다면?
TurnOn은 사실 필요가 없다.

그렇기에 인터페이스는 구현하는 객체들의 필요에 따라서 소규모로 분리하는것이 상속받아 구현하기 용이해진다.

<br>

### D : 의존 역전 원칙 (Dependency Inversion Principle)
<br>
`'고수준의 모듈은 저수준 모듈의 구현에 의존해선 안 된다.'` 

객체가 다른 객체를 참조할 때에는 필요한 기능이 있는 객체를 참조하되, 세부적으로 구현된 객체보다는 상위 객체(주로 인터페이스)를 
참조하는것이 좋다.

이건 또 무슨소리일까... 뒤쪽에 나와있듯이, 기능이 필요하다면 가능한 한 인터페이스를 통해 이용하라는 소리이다...

탈것을 예로 들어보자. 자동차 타입의 객체가 있다면 자동차 인스턴스를 만들어서 내부 함수를 사용할 수 있다.
```cs
Class Car{
    public void Ride(){ //자동차 탑승 }
}

Class Me{
    Car myVehicle;
    
    public void ChangeVehicle(Car _car)
    {
        myVehicle = _car;
    }
}

//main
{
    Me me = new Me();
    me.ChangeVehicle(new Car());
}
```

그런데 갑자기 비행기를 타는걸로 내부에서 바꾸고싶다면?
```cs
Class Car{
    public void Ride(){ //자동차 탑승 }
}

Class Airplane{
    public void Ride(){ //비행기 탑승 }
}

Class Me{
    Car myVehicle;
    
    public void ChangeVehicle(Car _car)
    {
        myVehicle = _car;
    }
}

//main
{
    Me me = new Me();
    me.ChangeVehicle(new Car());
}
```
어... me의 내부의 Car를 수정해야 한다...

이 문제는 `구현이 완료된 Car 객체를 참조`해서 발생하는 문제이다. 즉, 이 문제를 해결하기 위해서는
**상위 개념이 있는 부모 객체** 를 Car타입 대신 사용하거나 **인터페이스 타입** 을 이용하는 것이다.

인터페이스를 이용하게 된다면 코드는 다음과 같아진다.

```cs
Interface IVehicle{
    void Ride();
}

Class Car : IVehicle{
    public void Ride(){ // 자동차 탑승 } // 인터페이스 구현
}

Class Airplane : IVehicle{
    public void Ride(){ // 비행기 탑승 } // 인터페이스 구현
}

Class Me{
    IVehicle myVehicle;
    
    public void ChangeVehicle(IVehicle _vehicle)
    {
        myVehicle = _vehicle;
    }
}

//main
{
    Me me = new Me();
    me.ChangeVehicle(new Car());
    me.ChangeVehicle(new Airplane()); // Me 클래스의 수정 없이 교체 완료.
}
```

위와 같이 필수되는 특정 기능(들)만의 전환이 필요하다면 **인터페이스** 
기능들뿐만이 아닌 상호 호환되는 기능들을 포함한 데이터까지 필요하다 라는 상황이면 **추상클래스** 또는 **상속** 을 이용하는게 좋다.

<br>

## 클래스

그렇다면 객체를 어떻게 만드는걸까? 이를 위해서는 class라는 개념을 알아야 한다.
클래스에 대해 알아보자.

<br>

### 값타입, 참조타입

클래스에 들어가기에 앞서, c#에서의 데이터 저장 구조에 대해 조금 알아보자.

데이터의 저장영역은 크게 **스택** 영역과 **힙** 영역으로 구분된다.

**스택** : 후입선출 방식으로 데이터가 할당, 해제되며 기본 자료형, 구조체 등의 **값 타입** 데이터가 저장된다. 

**힙** : **참조 타입** 데이터가 저장되는 공간으로 **스택** 영역에 해당 참조타입 데이터의 주소를 가지는 변수가 저장된다.

<br>

**값 타입** : 스택에 저장되며, 할당 연산자등에 의해 전달될 때, 복사되어 전달된다. 이 복사본의 값 변경등은 원본값에 영향을 주지 않는다.

**참조 타입** : 언제나 **ref** 키워드를 가진다고 볼 수 있다. 할당 연산자 등으로 전달을 한다면 데이터 원본의 **주소** 를 전달하므로, 전달된 값을 통한
값의 변경은 **원본값** 에 영향을 끼친다.

<br>

### class

**class** 라는 개념은 보통 **설계도** 에 비유하곤 한다.

**클래스를 정의한다** 라는 것은 **설계도를 그린다** 라는 개념과 비슷하기 때문이다.

정말 간단한 클래스는 다음과 같은 형식도 가능하다.

```cs
class [클래스 타입]
{
}
```

클래스는 구조체와 내부 구조는 거의 다르지 않다.

즉, 변수와 함수들을 내부에 내포할 수 있으며, 접근제한자를 두어 외부에서 접근할 수 없게 만드는 것도 가능하다.

<br>

### 인스턴스

클래스를 가지고 실체를 가지는 데이터를 만들 수 있다. 이렇게 만들어진 데이터를 인스턴스라고 한다.

클래스가 정의되어 있다면, 해당 클래스 타입의 인스턴스를 **new** 키워드를 통해 만들 수 있다.

new를 통해 여러개의 인스턴스를 만든다면 여러개의 별도의 인스턴스가 생성되며 각자 다른 개체로 관리된다.

<br>